/**
 * Module:		UserSettings.ycp
 *
 * Authors:		Johannes Buchhold <jbuch@suse.de>
 *
 * Purpose:		Handle all settings from the files
 *			/etc/passwd
 *			/etc/shadow
 *			/etc/gshadow
 *			/etc/groups
 *
 *
 *
 * $Id$
 */
{

    module "UserSettings";
    textdomain "users";

    import "Mode";
    import "UserDefs";
    import "UserAddDefs";
    include "users/ui.ycp";
    include "users/passwd.ycp";

    /* TODO - make the maps local if possible */
    global map  current_users   = $[];
    global map  current_groups  = $[];
    global list current_gshadow = [];
    global map current_shadow = $[];

    path gshadow_path = .userscfg.gshadow;
    path passwd_path  = .userscfg.passwd;
    path group_path   = .userscfg.group;
    path shadow_path  = .userscfg.shadow;

    global string base_dir = "/etc";

    global list auto_shadow_symbols = [ "warn", "inact", "max", "min", "expire" ];

    global boolean aborted = false;

    /**
     * Read the file /etc/gshadow and save it to the list current_gshadow.
     * @return boolean true if success
     */
    global define boolean ReadGshadowFromDisk()``{
	current_gshadow  = [];
      string conf_path = base_dir + "/gshadow";
      string tmpfile = SCR::Read (.target.tmpdir) + "/gshadow";
      string data = sformat ("%1

`ag_anyagent(
  Description (
      ``(File(\"%2\")), // real filename
      \"#\",                      // Comment
      false,
      ``(List (
        Or (
          Tuple (
          `groupname (String(\"\")),
          \":\",
          `password (String(\"\")),
          \":\",
          `disposer (String(\"\")),
          \":\",
          `userlist (String(\"\"))
        ),

        Tuple (
          `groupname (Or (String(\"^:\"), \"\")),
          \":\",
          `password ( Or (String (\"^:\"), \"\") ),
          \":\",
          `disposer (Or (String (\"^:\"), \"\")),
          \":\",
          `userlist (Or (String (\"^\n\"), \"\"))
        )),
        \"\n\"
      ))
    )
)", gshadow_path, conf_path);
      SCR::Write (.target.string, tmpfile, data);
      SCR::RegisterAgent(gshadow_path, tmpfile);


	current_gshadow  = SCR::Read( gshadow_path );

	if ( current_gshadow == nil || current_gshadow == [] )
	{
	    y2error("Can't read file gshadow");
	    return false;
	}

	//remove empty entries
	current_gshadow  = filter(`k, current_gshadow , ``( size(k) > 1 ) );

	if( Mode::test )  y2milestone("Read file gshadow: %1", current_gshadow );
	return true;
    }

    /**
     * Read the file /etc/passwd and save it to the map current_users.
     * @return boolean true if success
     */
    global define boolean ReadPasswdFromDisk( ) ``{
      current_users = $[];
      string conf_path = base_dir + "/passwd";
      string tmpfile = SCR::Read (.target.tmpdir) + "/passwd";
      string data = sformat ("%1

`ag_anyagent(
  Description (
      ``(File(\"%2\")),  // real filename
      \"#\",                      // Comment
      true,
      ``(List (
        Or (
          Tuple (
          `username (String(\"+\")),
          \":\",
          `password (String (\"\")),
          \":\",
          `uid (String (\"\")),
          \":\",
          `gid (String (\"\")),
          \":\",
          `fullname (String (\"\")),
          \":\",
          `home (String (\"\")),
          \":\",
          `shell (String (\"\"))
        ),

        Tuple (
          `username (String (\"^:\")),
          \":\",
          `password (Or (String (\"^:\"), \"\")),
          \":\",
          `uid (Number ()),
          \":\",
          `gid (Number ()),
          \":\",
          `fullname (Or (String (\"^:\"), \"\")),
          \":\",
          `home (String (\"^:\")),
          \":\",
          `shell (String (\"^\n\"))
        )),
        \"\n\"
      ))
    )
)", passwd_path, conf_path);
      SCR::Write (.target.string, tmpfile, data);
      SCR::RegisterAgent(passwd_path, tmpfile);
      list users  = SCR::Read( passwd_path );
      if( users == $[] || users == nil )
      {
	  y2error("Can't read file passwd");
	  return false;
      }

      foreach ( `user, users,  ``{

	  any i_uid = user["uid"]:0;

	  user["exist"] = true;
	  if( is( i_uid , integer ) )
	  {
	      user["fullname"] = consoleUncoding( user["fullname"]:"");
	      user["org_home"] = user["home"]:"";
	      user["type"] = `passwd;
	      SetUser( i_uid , user );
	  }
      });
      if (! isNisMaster ())
      {
	string all_users = lookup (SCR::Execute (.target.bash_output, "getent passwd"), "stdout", "");

	users = SCR::Read (.run.getent.passwd);
	if (users == nil)
	    return;
	foreach ( `user, users,  ``{
	    any i_uid = user["uid"]:0;
	    user["exist"] = true;
            if( is( i_uid , integer ) )
            {
	        user["fullname"] = consoleUncoding( user["fullname"]:"");
	        user["org_home"] = user["home"]:"";
		user["type"] = `getent;
		if (lookup (current_users, i_uid, $[]) == $[])
		    SetUser( i_uid , user );
	    }

	});
      }
      if( Mode::test ) y2milestone("Read file passwd: %1", current_users);
      return true;
    }

    /**
     * Read the file /etc/group and save it to the map current_groups.
     * @return boolean true is success
     */
    global define boolean ReadGroupFromDisk( ) ``{
	current_groups = $[];

      string conf_path = base_dir + "/group";
      string tmpfile = SCR::Read (.target.tmpdir) + "/group";
      string data = sformat ("%1

`ag_anyagent(
  Description (
      ``(File(\"%2\")),   // real filename
      \"#\",                      // Comment
      true,
      ``(List (
        Or (
          Tuple (
          `groupname (String(\"+\")),
          \":\",
          `password (String (\"\")),
          \":\",
          `gid (String (\"\")),
          \":\",
          `userlist (String (\"\"))
        ),

        Tuple (
          `groupname (Username()),
          \":\",
          `password (Or (String (\"^:\"), \"\")),
          \":\",
          `gid (Number ()),
          \":\",
          `userlist (Or (String (\"^\n\"), \"\"))
        )),
        \"\n\"
      ))
    )
)", group_path, conf_path);
      SCR::Write (.target.string, tmpfile, data);
      SCR::RegisterAgent(group_path, tmpfile);

	list groups = SCR::Read( group_path );

	if( groups == [] || groups == nil )
	{
	    y2error("Can't read file group");
	    return false;
	}

	foreach ( `group, groups,  ``{
	    any i_gid = group["gid"]:0;
	    group["exist"]=  true;
	    if( is( i_gid , integer ) )
	    {
		//add group password form /etc/shadow
		string password =  getGroupPassword( group["groupname"]:"" );
		if ( password != nil ) group["password"]=  password;
		SetGroup(i_gid, group );
	    }
	});
	if( Mode::test ) y2milestone("Read file group: %1", current_groups);
	return true;
    }


    /**
     * Read the file /etc/shadow and save it to the list current_shadow.
     * @return boolean true if success
     */
    global define boolean ReadShadowFromDisk( ) ``{
      string conf_path = base_dir + "/shadow";
      string tmpfile = SCR::Read (.target.tmpdir) + "/shadow";
      string data = sformat ("%1

`ag_anyagent(
  Description (
      ``(File(\"%2\")),  // real filename
      \"#\",                      // Comment
      false,
      ``(List (
        Or (
          Tuple (
          `username (String(\"\")),
          \":\",
          `password (String(\"\")),
          \":\",
          `last_change (String(\"\")),
          \":\",
          `min (String(\"\")),
          \":\",
          `max (String(\"\")),
          \":\",
          `warn (String(\"\")),
          \":\",
          `inact (String(\"\")),
          \":\",
          `expire (String(\"\")),
          \":\",
          `flag (String(\"\"))
        ),

        Tuple (
          `username (Or (String(\"^:\"), \"\")),
          \":\",
          `password ( Or (String (\"^:\"), \"\") ),
          \":\",
          `last_change ( Or (String (\"^:\"), \"\") ),
          \":\",
          `min (Or (String (\"^:\"), \"\")),
          \":\",
          `max (Or (String (\"^:\"), \"\")),
          \":\",
          `warn (Or (String (\"^:\"), \"\")),
          \":\",
          `inact (Or (String (\"^:\"), \"\")),
          \":\",
          `expire (Or (String (\"^:\"), \"\")),
          \":\",
          `flag (Or (String (\"^\n\"), \"\"))
        )),
        \"\n\"
      ))
    )
)", shadow_path, conf_path);
      SCR::Write (.target.string, tmpfile, data);
      SCR::RegisterAgent(shadow_path, tmpfile);

      list shadow  = SCR::Read( shadow_path );
      current_shadow = $[];

      if( shadow == [] || shadow == nil )
      {
	  y2error("Can't read file shadow");
	  return false;
      }
      else
      {
	  // add shadow entries to current_users
	  foreach(`entry, shadow , ``{
	      string username =  entry["username"]:"";
	      map new_entry   = $[];

	      /* TODO fix expire and lstchg */

	      string work = entry["inact"]:sformat("%1",UserAddDefs::pass_inact_days );
	      if( work == "" ) work = sformat("%1", UserAddDefs::pass_inact_days);
	      new_entry["inact"] = tointeger( work );

	      work = entry["max"]:sformat("%1", UserDefs::pass_max_days );
	      if ( work == "" ) work = "0";
	      new_entry["max"]   = tointeger( work );

	      work = entry["min"]:sformat("%1", UserDefs::pass_min_days );
	      if( work == "") work = "0";
	      new_entry["min"]   = tointeger( work );

	      work = entry["warn"]:sformat("%1", UserDefs::pass_warn_age );
	      if( work == "") work = "0";
	      new_entry["warn"]  = tointeger( work );

	      work = entry["expire"]:sformat("%1", UserDefs::pass_warn_age );
              if( work == "") work = "0";
              new_entry["expire"]  = tointeger( work );

	      work = entry["last_change"]:sformat("%1", UserDefs::pass_warn_age );
              if( work == "") work = "0";
              new_entry["last_change"]  = tointeger( work );

	      current_shadow[ username ] = new_entry;
	  });

	  //add the shadow entry to the current_users map too.
	  foreach(`key, `user, current_users, ``{
	      string username = user["username"]:"";
	      user["shadow"] = current_shadow[username ]:$[];

	  });
      }
      return true;
    }

    /**
     * Read all users and groups settings.
     * @param interactive true if can ask user via popup
     */
    global define void ReadSettingsFromDisk(boolean interactive)``{
	if (interactive && isNisMaster ())
	{
	    string ypdir = SCR::Read(.sysconfig.ypserv.YPPWD_SRCDIR);
	    while (substring (ypdir, size (ypdir) - 1) == "/")
		ypdir = substring (ypdir, 0, size (ypdir) -1);
	    if ("" == ypdir)
		ypdir = "/";
	    if (ypdir != "/etc")
	    {
		symbol type = getConfigurationType (ypdir);
		if (type == `abort)
		{
		    aborted = true;
		    return false;
		}
		if (type == `nis)
		{
		    // this should never happen, probably only in testsuites
		    if (ypdir == nil)
			ypdir = "";
		    base_dir = ypdir;
		    UserWriteStack::chage = sformat ("/usr/bin/chage -P %1 ", ypdir);
		    UserWriteStack::useradd = sformat ("/usr/sbin/useradd -P %1 ", ypdir);
		    UserWriteStack::usermod = sformat ("/usr/sbin/usermod -P %1 ", ypdir);
		    UserWriteStack::userdel = sformat ("/usr/sbin/userdel -P %1 ", ypdir);
		    UserWriteStack::groupadd = sformat ("/usr/sbin/groupadd -P %1 ", ypdir);
		    UserWriteStack::groupdel = sformat ("/usr/sbin/groupdel -P %1 ", ypdir);
		    UserWriteStack::groupmod = sformat ("/usr/sbin/groupmod -P %1 ", ypdir);
		}
	    }
	}
	return (   ReadPasswdFromDisk()
		 && ReadGroupFromDisk()
		 && ReadGshadowFromDisk()
		 && ReadShadowFromDisk() );
    }
    /**
      * Get group id
      * @param groupname string group name
      * @return integer gid
      */
    global define integer GetGid( string groupname )``{

	integer gid = UserDefs::max_gid;
	foreach ( `key, `group,  current_groups, ``{
	    if( lookup( group, "groupname", "") == groupname )
	    {
		gid = lookup(group, "gid", UserDefs::max_gid  );
	    }
	});
	return gid;
    }
    /**
      * Get iser id
      * @param username string user name
      * @return integer uid
      */
    global define integer GetUid( string username )``{

        integer uid = UserDefs::max_uid;
        foreach ( `key, `user,  current_users, ``{
            if( lookup( user, "username", "") == username )
            {
                uid = lookup(user, "uid", UserDefs::max_uid  );
            }
        });
        return uid;
    }

    /**
     * Delete the group with groupname from current_gshadow.
     * @param groupname name of the group
     * @return void
     */
    global define void DeleteGroupFromShadow( string groupname )``{
	current_gshadow  = filter(`k, current_gshadow , ``( lookup(k, "groupname", "") != groupname ) );
    }

    /**
     * Return the group with groupname from current_gshadow.
     * @param groupname name of the group
     * @return map gshadow entry
     */
    global define map GetGroupFromShadow( string groupname ) ``{
	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname","") == groupname ) );
	if ( size ( password_group_list ) == 0 ) return $[];
	return select(password_group_list, 0,$[]);
    }

  /**
   * This define returns the groups of a user.
   * @param username the name of the user
   * @return string group comma separated list
   */
  global define string FindGroupsBelongUser( string username ) ``{
      if( username == "" ) return "";
      string grouplist = "";
      foreach( `key, `group, current_groups , ``{
	  string userlist      = lookup( group, "userlist","");
	  list   usersplitlist = splitstring( userlist, "," );

	  if( contains( usersplitlist, username ) )
	  {
	      string groupname = lookup( group, "groupname","");
	      if( grouplist == "" ) grouplist = groupname;
	      else grouplist = grouplist + "," + groupname;
	  }
      });

      if( grouplist != nil ) return grouplist;
      else return "";
  }

    /**
      * Split string of groups - estimation of behaviour
      * @param str_grouplist string list of groups
      * @return list of groups
      */
    global define list GroupString2groupList(string str_grouplist )``{

      list false_grouplist = [];
      list true_grouplist  = [];
      list str_list_grouplist = splitstring( str_grouplist, "," );

      foreach( `key, `group, current_groups , ``{
	  string groupname = lookup( group, "groupname","");

	  if( ! contains( str_list_grouplist, groupname ) )
	  {
	      term    a     = `item(`id(groupname ), groupname, false );
	      false_grouplist     = add( false_grouplist ,  a );
	  }
      });

      foreach( `groupname,  str_list_grouplist , ``{

	  term    a     = `item(`id(groupname ), groupname, true );
	  true_grouplist     = add( true_grouplist ,  a );
      });

      true_grouplist  = sort(true_grouplist);
      false_grouplist = sort(false_grouplist);

      return union( true_grouplist, false_grouplist);

  }

  /**
   * This define returns the users of a group.
   * This is used in usersGroupRead  and usersEditGroup.
   * @param gid integer group id
   * @param what symbol
   * @return list of users
   */
  global define list FindUsersBelongGroup( integer gid, symbol what ) ``{

      if( what == `string )
      {
	  string userlist     = lookup( lookup( current_groups, gid, $[]),  "userlist", "");
	  list split_userlist = splitstring( userlist, "," );

	  foreach( `key, `user, current_users , ``{

	      if ( gid == lookup(user, "gid", -1 ) &&(! contains( split_userlist, user["username"]:"" )  ))
	      {
		  if( userlist == "") userlist = lookup( user, "username", "");
		  else userlist = userlist + "," + lookup( user, "username", "");

		  split_userlist = add( split_userlist,  user["username"]:"" );
	      }
	  });
	  if (   userlist != nil )  return userlist;
	  else return "";
      }
      else
      {

	  string str_userlist    = lookup( lookup( current_groups, gid, $[]),  "userlist", "");
	  list str_list_userlist = [];

	  if( str_userlist != "" )
	      str_list_userlist = splitstring( str_userlist, "," );

	  list false_userlist          = [];
	  list true_userlist	       = [];

	  foreach( `key, `user, current_users , ``{

	      string username     =  lookup( user, "username", "");
	      //y2milestone( "%1", str_list_userlist );

	      if( (! contains(str_list_userlist,  username ) ))
	      {
		  if ( gid == lookup(user, "gid", -1))
		  {
		      term    a       = `item(`id(username), username, true );
		      true_userlist  =  add( true_userlist, a );
		  }
		  else
		  {
		      term    a       = `item(`id(username), username, false );
		      false_userlist  =  add( false_userlist, a );
		  }
	      }

	  });

	  foreach( `user, str_list_userlist, ``{
	      term    a     = `item(`id(user), user, true );
	      true_userlist = add( true_userlist, a );
	  });

	  true_userlist  = sort(true_userlist);
	  false_userlist = sort(false_userlist);

	  return union( true_userlist, false_userlist );

      }
  }


   /**
    * Return the groupname of a group.
    * @param Id the group gid
    * @return string groupname
    */
    global define string GroupIdToName( integer Id ) ``{
	return lookup(lookup( current_groups, Id,$[]), "groupname", "");
    }


    /**
     * Return the username of a user.
     * @param Id the user uid
     * @return string username
     */
    global define string UserIdToName( integer Id ) ``{
	return lookup( lookup( current_users, Id,$[]), "username", "");
    }



    /**
     * Convert the map current_groups to a list
     * @param todo specify the variant of the output list
     *	`items = build a item list for the group table
     *	`groupnamelist = list with all groupnames
     * @param view_all_groups boolean
     *   true  = add all groups to the output list
     *   false = add only groups with gid > max_system_gid
     * @return list of groups/items
     */
    global define list GroupsRead(symbol todo, boolean view_all_groups ) ``{


	list    items         = []; //list for the group table
	list    groupnamelist = []; //list with all groupnames

	foreach ( `key, `group,  current_groups, ``{

	    if ( group["todo"]:"" != `delete )
	    {
		if( todo == `items  &&
		    ( view_all_groups || ( ! view_all_groups && (key >  UserDefs::max_system_gid &&
								 group["groupname"]:"" != "nobody" &&
								 group["groupname"]:"" != "nogroup" ))))
		{
		    string  s_gid = sformat("%1", key   );
		    term    a     = `item(`id(key));

		     if( size( s_gid) != UserDefs::max_length_gid )
			 s_gid = addBlanks( UserDefs::max_length_gid - size(s_gid)) + s_gid;

		    a = add(a, group["groupname"]:"" );
		    a = add(a, s_gid);
		    a = add(a, FindUsersBelongGroup(key, `string ));

		    items = add( items, a );
		}

		if ( todo == `groupnamelist)
		{
		    groupnamelist = add(groupnamelist, group["groupname"]:"" );
		}
	    }
	});

	if( todo == `items              ) return items;
	else if (todo == `groupnamelist ) return groupnamelist;
    }

    /**
      * Return map for mapping user names to UIDs
      * @return map mapping
      */
    global define map UsersByName () ``{
	map res = $[];
	foreach (`k, `v, current_users, ``{
	    res = add (res, lookup (v, "username", ""), k);
	});
	return res;
    }
    /**
      * patch list of groups for each user to it's structure
      */
    global define void patchUsers () ``{
	foreach (`k, `v, current_users, ``{
	    current_users = add (current_users, k, add (v, "more groups", ""));
	});
	map mapping = UsersByName ();
	foreach (`k, `v, current_groups, ``{
	    list members = splitstring (lookup (v, "userlist", ""), ",");
	    string name = lookup (v, "groupname", "");
	    foreach (`m, members, ``{
		integer uid = lookup (mapping, m, 0);
		map u = lookup (current_users, uid, $[]);
		string grouplist = lookup (u, "more groups", "");
		grouplist = grouplist + "," + name;
		u = add (u, "more groups", grouplist);
		current_users = add (current_users, uid, u);
	    });
	});
    }


    /**
     * Convert the map current_users to a list.
     * @param todo specify the variant of the output list
     *  `items = build a item list for the user table
     *  `usernamelist = list with all usernames
     *  `homelist     = list with all homes
     * @param view_all_users boolean
     *   true  = add all users to the output list
     *   false = add only users with uid > max_system_uid
     * @return list of users/items
     */
    global define list UsersRead(symbol todo, boolean view_all_users ) ``{

	list     todo_list    = [];
	list     items        = []; // item list for the user table

	patchUsers ();

	foreach ( `key, `user,  current_users, ``{

	    if(  user["todo"]:"" != `delete )
	    {
		string username = user["username"]:"";

		if( todo == `items &&
		    ( view_all_users || ( ! view_all_users && (key >  UserDefs::max_system_uid  && user["username"]:"" != "nobody" ))))
		{
		    string  s_uid = sformat("%1", key );
		    term    a     = `item(`id(key));

		    if( size( s_uid) !=  UserDefs::max_length_uid )
			s_uid = addBlanks(  UserDefs::max_length_uid - size(s_uid)) + s_uid;

		    a =	add(a, username );

		    if(key > UserDefs::max_system_uid)
			a = add(a, user["fullname"]:"" );
		    else
			a = add(a, SystemUsers[username]:user["fullname"]:"" );

		    a = add(a, s_uid );

		    string grouplist   = lookup(lookup( current_groups , lookup( user, "gid", 0),$[]), "groupname","");
		    string more_groups = substring (lookup (user, "more groups", ","), 1);

//FindGroupsBelongUser( username );

		    if ( contains ( splitstring( more_groups , "," ) , grouplist )) grouplist = more_groups;
		    else
		    {
			if( more_groups != "" ) grouplist = grouplist + "," + more_groups;
		    }

		    a = add(a, grouplist );

		    items = add( items, a );
		}
		else if ( todo == `usernamelist && username != "")
		{
		    todo_list = add(todo_list, username );

		}
		else if ( todo == `homelist && username != "" )
		{
		    todo_list = add(todo_list, user["home"]:"" );
		}
	    }
	});

	if( todo == `items                               ) return  items;
	else if( todo == `usernamelist || todo == `homelist ) return todo_list;

    }


    /**
     * Scan usersettings for the next free uid.
     * @return integer free uid
     */
    global define integer NextFreeUid() ``{

	integer uid     =  UserDefs::max_system_uid + 1 ;
	repeat {
	    if (  haskey( current_users , uid) )
	    {
		map user =  lookup ( current_users , uid ,$[]);
		if( user["todo"]:"" == `delete) return uid;
		else
		{
		    uid = uid + 1;
		}
	    }
	    else return uid;

	} until ( uid ==  UserDefs::max_uid );
	return uid;
    }



    /**
     * Scan the groupsettings the next free gid.
     * @return integer free gid
     */
    global define integer NextFreeGid() ``{

	integer gid  =  UserDefs::max_system_gid + 1;

	// can't delete gid 101 with groupdel ????
	// FIXME ERROR
	if ( gid == 101 ) gid = 102;

	repeat {
	    if ( haskey( current_groups, gid ) )
	    {
		map group = current_groups[ gid ]:$[] ;
		if( group["todo"]:""  == `delete) return gid;
		else
		{
		    gid = gid + 1;
		    if ( gid == 101 ) gid = 102;
		}
	    }
	    else return gid;
	} until ( gid ==  UserDefs::max_gid );
	return gid;
    }



    /**
     * Return the settings for a user.
     * @param uid the user id
     * @return map of user
     */
    global define map GetUser( integer uid )``{
	return current_users[ uid ]:$[];
    }

    /**
      * Delete user
      * @param uid the user id
      */
    global define void DelUser( integer uid ) ``{

	UserSettings::current_users = filter( `key, `user, UserSettings::current_users, ``( uid != key));
    }

    /**
     * Return the settings for a group.
     * @param gid the group id
     * @return map of group
     */
    global define map GetGroup( integer gid )``{
	return current_groups[ gid ]:$[];
    }

    /**
     * Update the settings for a user.
     * @param uid the user id
     * @param user the new settings for the user
     */
    global define void SetUser( integer uid , map user)``{
	current_users[ uid ] = user;
    }

    /**
     * Update the settings for a group.
     * @param gid the group id
     * @param group the new settings for the group
     */
    global define void SetGroup( integer gid , map group )``{
	current_groups[ gid ] = group;
    }

    /**
      * Delete group
      * @param gid integer group id
      */
    global define void DelGroup( integer gid ) ``{
	UserSettings::current_groups = filter( `key, `group, UserSettings::current_groups, ``( gid != key));
    }
    /**
      * Set group name for group specified by GID
      * @param gid integer group id
      * @param groupname string new name for group
      * @return true if success
      */
    global define boolean SetGroupname( integer gid, string groupname) ``{
	map current_group = current_groups[gid]:$[];
	if ( current_group == $[] )
	{
	    y2milestone(sformat("The group with the gid %1 does not exist", gid));
	    return false;
	}
	else
	{
	    current_group["groupname"] = groupname;
	    current_groups[gid]        = current_group;
	    return true;
	}
    }
    /**
      * Get group name for group id
      * @param gid integer group id
      * @return strign group name
      */
    global define string GetGroupname( integer gid )``{
	map current_group = current_groups[gid]:$[];
	if ( current_group == $[] )
	{
	    y2milestone(sformat("The group with the gid %1 does not exist", gid));
	    return "";
	}
	else
	{
	    return current_group["groupname"]:"";
	}
    }
    /**
      * Set list of users having additional membership for specified group
      * @param gid integer group id
      * @param userlist string comma separated list of users
      * @return boolean true if success
      */
    global define boolean SetUserlist( integer gid, string userlist ) ``{
	map current_group = current_groups[gid]:$[];

	if ( current_group == $[] )
	{
	    y2milestone(sformat("The group with the gid %1 does not exist", gid));
	    return false;
	}
	else
	{
	    current_group["userlist"] = userlist;
	    current_groups[gid]       = current_group;
	    return true;
	}
    }
    /**
      * Get list of users having additional membership for specified group
      * @param gid integer group id
      * @return string comma separated list of users
      */
    global define string GetUserlist( integer gid )``{
	map current_group = current_groups[gid]:$[];
	if ( current_group == $[] )
	{
	    y2milestone(sformat("The group with the gid %1 does not exist", gid));
	    return "";
	}
	else
	{
	    return current_group["userlist"]:"";
	}
    }

    /**
     * Add a group password entry.
     * @param gshadow new entry for gshadow
     *
     */
    global define void AddGshadowEntry( map gshadow )``{
	current_gshadow = add( current_gshadow , gshadow );
    }



    /**
     * Return the group password if the group have a password ( use current_gshadow ).
     * @param groupname name of the group
     * @return string/nil group password
     */
    define string getGroupPassword( string groupname ) ``{

	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname","") == groupname ) );
	if( size (password_group_list ) == 0 ) return ( nil ) ;

	string password = lookup( select(password_group_list, 0,$[]) , "password", "" );
	if( (password != "*" ) &&
	    ( password  != "!" ) ) return password;
	return ( nil ) ;
    }


    /**
     * Uncode the fullname.
     * @param fullname fullname of the user
     * @return string recoded fullname
     */
    define string consoleUncoding( string fullname ) ``{
	return UI::Recode( UserDefs::encoding,"UTF-8",  fullname );
    }


    /**
     * Build a string with n blanks
     * @param count number of blanks
     * @return string of blanks
     */
    define string addBlanks(integer count ) ``{
	string  blanks = "";
	integer blanks_counter = 0;

	while (  blanks_counter < count )
	{
	    blanks_counter = blanks_counter + 1;
	    blanks         = blanks + " ";
	}
	return blanks;
    }

    /**
      * Backup /etc/passwd, shadow, group and gshadow files
      */
    global define void BackupConfFiles()``{
	// save old settings
	// TODO Fixme -> use local path values
	SCR::Execute(.target.bash, sformat ("/bin/cp %1/shadow %1/shadow.YaST2save", base_dir));
	SCR::Execute(.target.bash, sformat ("/bin/cp %1/passwd %1/passwd.YaST2save", base_dir));
	SCR::Execute(.target.bash, sformat ("/bin/cp %1/gshadow %1/gshadow.YaST2save", base_dir));
	SCR::Execute(.target.bash, sformat ("/bin/cp %1/group %1/group.YaST2save", base_dir));
    }



    /**
     * Change the username in current_groups.
     * @param old_username the old username
     * @param username     the new username
     * @return boolean true if success
     */
    global define boolean ChangeUserNameInGroups(string old_username, string username)``{

	// if the username has been changed update the map current_groups
	map    tmp_current_groups = current_groups;

	if ( old_username != username )
	{
	    foreach( `key, `group, current_groups, ``{

		string userlist       =  lookup( group , "userlist" ,"");
		list   split_userlist =  splitstring( userlist, ",");
		if ( contains( split_userlist , old_username ) )
		{
		    list   new_userlist     =  filter(`v, split_userlist , ``(v != old_username ));
		    list   new_userlist     =  add( new_userlist, username );
		    string new_userlist_str =  mergestring( new_userlist, ",");
		    group  = add(group, "userlist", new_userlist_str );
		    tmp_current_groups = add( tmp_current_groups, key, group );
		}
	    });
	    current_groups = tmp_current_groups;
	}
	return true;
    }


    /**
     * Change the userlist in current_groups.
     * Add and remove entries form the userlist
     * @param username the name of the changed user
     * @param grouplist the new grouplist of the changed user
     * @return boolean true if succeses
     */
    global define boolean ChangeUserlistInGroups( string username, string grouplist )``{

	map tmp_current_groups = current_groups;
	list search_groups = splitstring(grouplist, "," );

	foreach( `key, `group, tmp_current_groups, ``{
	    string userlist      = lookup(group, "userlist" , "");
	    list split_userlist  = splitstring( userlist, ",");
	    map    new_group     = group;

	    // delete username from userlist
	    if( contains( split_userlist, username )  &&( ! contains(search_groups, lookup( group, "groupname","")) ))
	    {
		string new_userlist = "";

		foreach( `entry, split_userlist, ``{

		    if( entry != username )
		    {
			if( new_userlist == "") new_userlist = entry;
			else new_userlist = new_userlist + "," + entry;
		    }
		});
		new_group = add( new_group, "userlist", new_userlist );

		// write update to current_groups
		SetGroup( key , new_group );
	    }

	    // add username to userlist
	    if(	 contains(search_groups, lookup( group, "groupname","")) &&( ! contains(split_userlist, username )))
	    {
		if ( userlist == "" ) userlist = username;
		else userlist = userlist + "," + username;

		new_group["userlist"] = userlist;

		//write update to current_groups
		SetGroup( key , new_group );
	    }
	});

	return true;
    }


    /**
     * delete the user from the map current_groups (userlist)
     * @param username string username
     */
    global define void DelUserFromAllGroups( string username )``{

	foreach( `key, `group, UserSettings::current_groups, ``{

	    string userlist  = group["userlist"]:"";
	    map    new_group = group;

	    if( issubstring( userlist, username ) )
	    {
		list split_userlist = splitstring( userlist, ",");
		string new_userlist = "";

		foreach( `entry, split_userlist, ``{

		    if( entry != username )
		    {
			if( new_userlist == "") new_userlist = entry;
			else new_userlist = new_userlist + "," + entry;
		    }
		});
		new_group[ "userlist"] =  new_userlist;
		UserSettings::SetGroup( key , new_group );
	    }
	});

    }

    /**
     * Remove all users from the userlist with a default group (gid)
     * that is part of the userlist.
     * @param old_gid the gid
     * @param split_userlist the userlist
     * @return string new users list
     */
    global define string RemoveDefaultUserFromUserlist( integer old_gid , list split_userlist)``{

	string new_userlist     = "";

	map    default_users  =  filter(`k, `v, current_users, ``(lookup(v,"gid",nilinteger) == old_gid) );
	foreach(`entry, split_userlist, ``{

	    if(  (size(filter(`k, `v, default_users, ``(lookup(v,"username",nilinteger ) == entry ))) == 0 ) ||
		 ( issubstring(lookup( GetGroup( old_gid ), "userlist",""), entry ) ))
	    {
		if( new_userlist == "") new_userlist = entry;
		else new_userlist = new_userlist + "," + entry;
	    }
	});

	return new_userlist;
    }


    /**
     * Change the group id and the content of a group.
     * @param old_gid the old group id
     * @param gid the new group id
     * @param current_group the new entry for the new group id
     */
    global define void ChangeGid( integer old_gid, integer gid, map current_group )``{

	map    default_users  =  filter(`k, `v, current_users, ``(lookup(v,"gid",nilinteger) == old_gid) );

	current_groups = filter(`key, `group, current_groups,``( key != old_gid ));

	/*
	map new_current_groups = $[];
	foreach( `key, `group, current_groups, ``{
	    if( key != old_gid) new_current_groups = add( new_current_groups, key, group );
	});
	current_groups = new_current_groups;
	*/

	foreach( `key, `user, default_users, ``{

	    map new_user = user;
	    new_user     = add( new_user, "gid", gid);
	    SetUser( key, new_user);
	});

	SetGroup( gid, current_group );
    }
    /**
      * Test function
      */
    global define void Test()``{

	UserDefs::Read();
	ReadPasswdFromDisk();
	ReadGroupFromDisk();
	ReadGshadowFromDisk();
	ReadShadowFromDisk();

	y2milestone("current_users:---------------------------------------------");
	y2milestone(sformat("%1",current_users));
	y2milestone("current_groups:---------------------------------------------");
	y2milestone(sformat("%1",current_groups));
	y2milestone("current_gshadow:---------------------------------------------");
	y2milestone(sformat("%1",current_gshadow));

    }

    /**
      * Check whether host is NIS master
      * @return boolean true if is master
      */
    global define boolean isNisMaster () ``{
	boolean helper = 0 == SCR::Execute (.target.bash, "test -f /usr/lib/yp/yphelper");
	if (! helper)
	    return false;
	boolean master = 0 == SCR::Execute (.target.bash, "/usr/lib/yp/yphelper --domainname `domainname` --is-master passwd.byname");
	return master;
    }
}
