/**
 * File:
 *  users/io.ycp
 *
 * Module:
 *  Configuration of the users and groups
 *
 * Summary:
 *  Input/Output routines for the users module
 *
 * Authors:
 *  Jan Holesovsky <kendy@suse.cz>, 2001
 *  Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 * Input/Output routines.
 */

{

  textdomain "users";
  
  
    /**
     * Return the group password if the group have a password ( use current_gshadow ) 
     * @param string  <TT>groupname</TT>
     */
    global define usersGroupPassword( string groupname ) ``{
	
	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname") == groupname ) );
	if( size (password_group_list ) == 0 ) return ( nil ) ;
	
	string password = lookup( select(password_group_list, 0) , "password", "" );
	if( (password != "*" ) &&
	    ( password  != "!" ) ) return password;
	return ( nil ) ;
    }

    
    /**
     * Delete the group with the groupname from current_gshadow
     * @param string  <TT>groupname</TT>
     */
    global define usersDeleteGroupFromShadow( string groupname )``{
	current_gshadow  = filter(`k, current_gshadow , ``( lookup(k, "groupname") != groupname ) );
    }


    /**
     * Return the group with the groupname from current_gshadow
     * @param string  <TT>groupname</TT>
     */
    global define usersReturnGroupFromShadow( string groupname ) ``{
	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname") == groupname ) );
	if ( size ( password_group_list ) == 0 ) return $[]; 
	return select(password_group_list, 0);
    }


    
   /**
   * Read the /etc/gshadow file and save it to current_gshadow. 
   * This is used in users.ycp and in usersSaveDialog()
   * @param 
   */
    global define  usersGroupsShadowReadFromDisk() ``{
	
	current_gshadow  = SCR(`Read(.etc.gshadow));
	current_gshadow  = filter(`k, current_gshadow , ``( size(k) > 1 ) );
	if( test_mode )    SCR(`Write(.dumpto.tmp.current_gshadow,  current_gshadow  ));
    }  
    
  /**
   * This define returns the groups of a user
   * This is used in <TT>usersUserSaveToMap </TT> and <TT>usersGroupSaveToMap</TT> and
   * <TT>usersUsersRead</TT> and <TT>usersEditUser</TT>
   * @param string <TT>username</TT>
   */
  global define findGroupsBelongUser( string username ) ``{

      if( username == "" ) return "";
      string grouplist = "";
      foreach( `key, `group, current_groups , ``{
	    
	    string userlist = lookup( group, "userlist");
	    if ( issubstring(userlist , username ))
	    {
		string groupname = lookup( group, "groupname");
		if( grouplist == "" ) grouplist = groupname;
		else grouplist = grouplist + "," + groupname;
	    }
	});
	
	if( grouplist != nil ) return grouplist;
	else return "";
    }


  
   /**
   * This define returns the users of a group
   * This is used in <TT>usersGroupRead </TT> and <TT>usersEditGroup</TT>
   * @param integer <TT>gid</TT>
   */
  global define findUsersBelongGroup( integer gid ) ``{

      string userlist = lookup( lookup( current_groups, gid),  "userlist", "");
      foreach( `key, `user, current_users , ``{
	  
	  if ( gid == lookup(user, "gid") &&(! issubstring(userlist,  lookup( user, "username", "") )))
	  {
	      if( userlist == "") userlist = lookup( user, "username", "");
	      else userlist = userlist + "," + lookup( user, "username", "");
	  }
      });
      if (   userlist != nil )  return userlist;
      else return "";
  }
  

  /**
   * Read the /etc/passwd file and save it to current_users. 
   * This is used in users.ycp 
   * @param 
   */
  global define usersUsersReadFromDisk() ``{

	list users  = SCR(`Read(.etc.passwd));
	foreach ( `user, users,  ``{
	    any i_uid = lookup(  user, "uid", 0);
	    user = add( user ,"exist", true);
	  
	    if( is( i_uid , integer ) )
	    {
		user = add( user , "fullname", usersConsoleUncoding( lookup( user, "fullname" ,"" )));
		current_users = add(current_users, i_uid , user );
	    }	
	});
    }


  /**
   * Read the /etc/group file and save it to current_groups. 
   * This is used in users.ycp 
   * @param 
   */
  global define usersGroupsReadFromDisk() ``{

	list groups = SCR(`Read(.etc.group ));    
	foreach ( `group, groups,  ``{
	    any i_gid = lookup( group, "gid", 0);
	    group = add(group, "exist", true);
	    if( is( i_gid , integer ) )
	    {
		//if a password in /etc/gshadow for this group a this password and
		//the group to current_groups
		string password =  usersGroupPassword( lookup( group, "groupname" , "" ));
		if ( password != nil ) group = add( group, "password", password );
		
		current_groups = add(current_groups, i_gid , group );
	    }	
	});
    }
 
   /**
    * Return the groupId of a groupname  
    * Not used 
    * @param string <TT>groupname</TT> 
    */
   global define groupNameToId( string groupname) ``{

	integer ret = max_gid;
	foreach( `key, `group, current_groups, ``{
	    if( (lookup(group, "groupname", "") == groupname) &&
		(lookup(group, "todo", "" ) != `delete) )
		{
		    ret = key;
		}
	});
	return ret;
    }


   
   /**
    * Return the groupname of a groupId 
    * Used in <TT>usersUserSaveToMap</TT>
    * @param integer <TT>Id</TT> 
    */
    global define groupIdToName( integer Id ) ``{
	return lookup(lookup( current_groups, Id), "groupname", "");
    }


    /**
     * Return the username of a userId 
     * Used in <TT>usersUserSaveToMap</TT>
     * @param integer <TT>Id</TT> 
     */
    global define userIdToName( integer Id ) ``{
	return lookup( lookup( current_users, Id), "username", "");
    }


    /**
     * Return the size of the map user_settings 
     * Used in <TT>usersAddTodo</TT>
     * @param 
     */
    global define findNextTodoPos() ``{
	return  ( size( user_settings) + 1);
    }


    
    /**
     * Add a string to the map user_settings for a todo position 
     * Used in <TT>usersAddMakeHomeDir</TT>, <TT>usersAddMoveDir</TT>, <TT>usersAddChownHome</TT>,
     * <TT>usersUserSaveToMap</TT>, <TT>usersGroupSaveToMap</TT>, <TT>usersDeleteUser</TT> and
     * <TT>usersDeleteGroup</TT>
     * @param string <TT>todo</TT>
     */
    global define usersAddTodo( string todo, symbol what, string error ) ``{
	
	user_settings = add( user_settings ,  findNextTodoPos(),  $[ "todo" : todo,
								     "what" : what,
								     "error": error ] );
	return true;
    }

    
    /**
     * Add a string to the map user_settings for creating a home dir for a new user 
     * Used in <TT>usersAddMoveDir</TT> and <TT>usersUserSaveToMap</TT>
     * @param string <TT>home</TT>
     */
    global define usersAddMakeHomeDir( string home ) ``{

	list   split_home = splitstring( home, "/");
	string tmp_dir    = "";

	foreach( `sub_dir, split_home , ``{
	    if( sub_dir != "" )
	    {
		tmp_dir = tmp_dir + "/"+sub_dir;
		if( nil == Dir(tmp_dir) )  usersAddTodo( ("/bin/mkdir " + tmp_dir),
							 `mkdir,
							 sformat(UI(_("Can't make directory %1")), tmp_dir));
	    }
	});
    }

    
    /**
     * Add a string to the map user_settings for creating a home dir for a new user 
     * Used in <TT>usersAddMoveDir</TT> and <TT>usersUserSaveToMap</TT>
     * @param string <TT>home</TT>
     */ 
    global define usersAddMoveDir(string old_home, string  home )``{

	usersAddTodo( ("/bin/mv " + old_home + " " +  home ),
		      `mv,
		      sformat(UI(_("Can't move old home directory %1
to new home directory %2")), old_home, home));
	

    }

    /**
     * Add a string to the map user_settings for removing a home directory 
     * Used in <TT>usersDeleteUser</TT>
     * @param string <TT>home</TT>
     */ 
    global define usersAddRmDir( string  home )``{

	usersAddTodo( ("/bin/rm " +home + " -r" ),
		      `rm,
		      sformat(UI(_("Can't remove home directory %1.")),  home));
    }
    /**
     * Add a string to the map user_settings to set the home dir access right
     * Used in <TT>usersUserSaveToMap</TT>
     * @param string <TT>home</TT>, string <TT>user</TT> and string <TT>group</TT>
     */ 
    global define usersAddChownHome( string home, string user, string group)``{

	usersAddTodo(("/bin/chown  " + user + ":" + group + " " + home ),
		     `chown,
		     UI(_("Can't set user and group variable to the home directory")));
	
	usersAddTodo(("/bin/chmod g-rx " + home ),
		     `chown,
		     UI(_("Can't set read and write permissions to the home directory")));

	usersAddTodo(("/bin/chmod o-rx " + home ),
		     `chown,
		     UI(_("Can't set read and write permissions to the home directory")));
    }


    global define usersAddSetGroupPassword( string groupname, string password ) ``{

	user_settings = add( user_settings ,
			     findNextTodoPos(),
			     $[
			       "groupname" : groupname,
			       "password"  : password,
			       "what" : `set_group_password, 
			       "error": UI(_("Can' set group password" ))
			     ]
			     );
	return true;
	
    }
    
    
    /**
     * Add a string to the map user_settings to save a new or modified user 
     * Used in sequenser
     * @param 
     */ 
    global define usersUserSaveToMap() ``{

	symbol  what     = lookup( user_in_work , "what"      , `nix );
	string  fullname = lookup( user_in_work , "fullname"  , ""   );
	integer gid      = lookup( user_in_work , "gid"       , max_gid );
	string  home     = lookup( user_in_work , "home"      , ""   );
	string  password = lookup( user_in_work , "password"  , ""   );
	string  shell    = lookup( user_in_work , "shell"     , ""   );
	integer uid      = lookup( user_in_work , "uid"       , max_uid );
	string  username = lookup( user_in_work , "username"  , ""   );
	string  grouplist= lookup( user_in_work , "grouplist" , ""   );
	string  todo     = "/usr/sbin/usermod";
	boolean do_exist = true;
	map     org_user = lookup( current_users, uid , $[]);
	string  comment  = usersConsoleEncoding( fullname );
		      
	// ToDo write a User;
	if ( what == `add_user )
	{
	    do_exist = false;

	    //add shell, home, initial_group, password, uid to string
	    todo = sformat("/usr/sbin/useradd -s %1 -d %2 -g %3 -m -p '%4' -u %5 -o",shell, home, groupIdToName(gid ), password, uid);

	    //add fullname to string (comment)
	    if ( comment  != "") todo = todo + " -c " + comment;

	    //add groups to string
	    if ( grouplist != "") todo = todo + " -G " + grouplist;

	    //add username to string
	    todo = todo + " " + username;

	    usersAddMakeHomeDir( home );

	    if( fileexist ("/usr/sbin/useradd.local") )
	    {	
		usersAddTodo( ("/usr/sbin/useradd.local " + username ),
			      `add_user_local,
			      UI(_("Can't execute /usr/sbin/useradd.local")));
	    }


	    usersAddTodo( todo ,
			  `add_user,
			  sformat(UI(_("Can't create the new user %1")), username ) );
	    
	    usersAddChownHome( home, username , groupIdToName(gid ));
	}
	else
	{
	    //add initial_group to string 
	    if ( lookup( org_user, "gid" ,     "" ) != gid      )  todo = todo + " -g "  + groupIdToName(gid  );

	    //add comment to string 
	    if ( lookup( org_user, "fullname", "" ) != fullname )  todo = todo + " -c " + comment ;

	    //add home_dir to string
	    if ( lookup( org_user, "home" ,    "" ) != home     )
	    {
		todo = todo + " -d "  + home;
		usersAddMoveDir(lookup( org_user, "home" ,    "" ),  home );
	    }

	    //add password to string 
	    if ( "x" != password )  todo = todo + " -p '"  + password + "'";

	    //no change id at the moment 
            // if ( lookup( org_user, "uid",      "")  != uid     )  todo = todo + " -u " + sformat("%1", uid ) + " -o";

	    //add loginname to string
	    if ( lookup( org_user, "username" ,"")  != username )  todo = todo + " -l "  + username;

	    //add shell to string
	    if ( lookup( org_user, "shell" , "") != shell ) todo = todo + " -s " + shell;
	    
	    //add groups to  string
	    if ( findGroupsBelongUser(username )    != grouplist)
	    {
		if ( grouplist == "" ) grouplist = "''";
		todo = todo + " -G "  + grouplist;
	    }

	    // add username to string
	    if( todo !=  "/usr/sbin/usermod" )
	    {
		todo = todo + " " + userIdToName( uid );
	    
		usersAddTodo( todo,
			      `edit_user,
			      sformat(UI(_("Can't change the settings of the user %1")), username ));
	    

		if ( lookup( org_user, "username" ,"")  != username  ||
		     lookup( org_user, "gid" ,     "" ) != gid       ||
		     lookup( org_user, "home" ,    "" ) != home      	 )
		{  
		    usersAddChownHome( home, username , groupIdToName(gid ));
		}
	    }
	}


	
	map current_user = $[
			     "exist"    : do_exist,
			     "fullname" : fullname,
			     "gid"      : gid,
			     "home"     : home,
			     "password" : password,
			     "shell"    : shell,
			     "uid"      : uid,
			     "username" : username
	];	

	
	list search_groups = splitstring(grouplist, "," );

	
	// if the username was changed
	// the map current_groups must be updated
	map    tmp_current_groups = current_groups;
	string old_username       = lookup( org_user , "username" , "" );
	if ( old_username != username )
	{
	    map groups_with_old_username = filter(`k, `v, current_groups, ``( issubstring(lookup(v,"userlist"),old_username) == true ));
	    foreach( `key, `group, current_groups, ``{
		
		string userlist       =  lookup( group , "userlist" ,"");
		list   split_userlist =  splitstring( userlist, ",");
		if ( contains( split_userlist , old_username ) )
		{
		    list   new_userlist     =  filter(`v, split_userlist , ``(v != old_username ));
		    list   new_userlist     =  add( new_userlist, username );
		    string new_userlist_str =  mergestring( new_userlist, ",");
		    group  = add(group, "userlist", new_userlist_str );
		    tmp_current_groups = add( tmp_current_groups, key, group );
		}
	    });
	    current_groups = tmp_current_groups;
	}
	

	
	//If the userlist has changed the map current_groups 
	//must be updated
	// add or delete user from userlist
	foreach( `key, `group, tmp_current_groups, ``{
	    string userlist  = lookup(group, "userlist" , "");
	    map    new_group = group;
	    
	    if( issubstring( userlist, username ) &&( ! contains(search_groups, lookup( group, "groupname")) ))
	    {
		//UI(`MessagePopup("delete " + username + " from " +  lookup( group, "groupname") ));
		// delete username from userlist
		list split_userlist = splitstring( userlist, ",");
		string new_userlist = "";
		
		foreach( `entry, split_userlist, ``{

		    if( entry != username )
		    {
			if( new_userlist == "") new_userlist = entry;
			else new_userlist = new_userlist + "," + entry;
		    }
		});
		new_group = add( new_group, "userlist", new_userlist );
		current_groups = add( current_groups, key , new_group );
	    }
	    if(	 contains(search_groups, lookup( group, "groupname")) &&( ! issubstring( userlist, username )))
	    {
		//UI(`MessagePopup("add " + username + " to " + lookup( group, "groupname") ));
		// add username to userlist
		if ( userlist == "" ) userlist = username;
		else userlist = userlist + "," + username;

		new_group = add( new_group, "userlist", userlist );
		current_groups = add( current_groups, key , new_group );
	    }
	});
	current_users = add( current_users , uid, current_user );

	
	if( test_mode ) SCR(`Write(.dumpto.tmp.user_settings,   user_settings  ));

	//leave the module with save
	if (  start_dialog == "user_add" ) return `save;
	return `next;
    }

    
     /**
     * Add a string to the map user_settings to save a new or modified group 
     * Used in sequenser
     * @param 
     */ 
    global define  usersGroupSaveToMap( ) ``{

	   //load the manipulated group from group_in_work
	   symbol what             = lookup( group_in_work , "what" ,     "");
	   string new_groupname    = lookup( group_in_work, "groupname",  "");
	   string password         = lookup( group_in_work, "password",   "x");
	   string userlist         = lookup( group_in_work, "userlist",   "");
	   integer gid             = lookup( group_in_work, "gid",        "");
	   integer old_gid         = lookup( group_in_work, "old_gid",    "");
	
	 
	   // remove default user from the userlist
	   list   split_userlist = splitstring( userlist, ",");
	   string new_userlist   = "";
	   map    default_users  =  filter(`k, `v, current_users, ``(lookup(v,"gid") == old_gid) );
	   foreach(`entry, split_userlist, ``{
	      
	       if(  (size(filter(`k, `v, default_users, ``(lookup(v,"username") == entry ))) == 0 ) ||
		    ( issubstring(lookup(lookup(current_groups, old_gid , $[] ), "userlist"), entry ) ))
		   {
		       if( new_userlist == "") new_userlist = entry;
		       else new_userlist = new_userlist + "," + entry;       
		   }
	   });

	   
	   // build strings with the operation and save they to user_settings
	   string  todo     = "/usr/sbin/groupmod";	
	   boolean do_exist = true;
	   if ( what == `add_group )
	   {
	       do_exist = false;
	       
	       usersAddTodo( sformat("/usr/sbin/groupadd -g %1 -o %2", gid, new_groupname ),
			     `add_group,
			     sformat(UI(_("Can't create new group %1")), new_groupname));
	       
	       if ( userlist != "" )
	       {
		   list split_userlist = splitstring( userlist , "," );
		   foreach ( `user, split_userlist, ``{  
		       string new_G = findGroupsBelongUser(user);
		       if ( new_G != "" )  new_G = new_G + "," + new_groupname;
		       else new_G  = new_groupname;
		       usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_G, user ),
				     `edit_user,
				     sformat(UI(_("Can't add user %1 to group %2")), user, new_G));
		   });
	       }
	   }
	   else
	   {
	       string old_groupname = lookup( lookup( current_groups , old_gid, $[] ), "groupname" , "" );
	       
	       if ( lookup( lookup( current_groups , old_gid, $[] ), "userlist" ,  "" ) != userlist )
	       {
		   
		   string old_userlist       = lookup( lookup( current_groups , old_gid, $[] ), "userlist" ,  "" );
		   list   old_split_userlist = splitstring( old_userlist, ",");
		   list       split_userlist = splitstring(     userlist, ",");
		   symbol add_or_delete      = `add;
		   list  work_userlist       = [];
		   
		   
		   if ( size ( old_userlist ) < size( userlist ) )
		   {
		       //add user-s to group
		       foreach(`user, split_userlist ,``{
			   if( !contains( old_split_userlist, user) ) work_userlist = add( work_userlist, user );
		       });
		       
		       foreach( `user, work_userlist, ``{
			   string new_G = findGroupsBelongUser(user);
			   if ( new_G != "" )  new_G = new_G + "," + old_groupname;
			   else new_G  = old_groupname;
			   usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_G , user ),
					 `edit_user,
					 sformat(UI(_("Can't add user %1 to group %2")), user, new_G));
		       });
		   }
		   else
		   {
		       //delete user-s  from group
		       add_or_delete = `delete;
		       foreach(`user, old_split_userlist ,``{
			   if( !contains( split_userlist, user) ) work_userlist = add( work_userlist, user );
		       });
		       foreach( `user, work_userlist, ``{
			   string new_G      = findGroupsBelongUser(user);			   
			   list   new_G_list = splitstring( new_G , "," );
			   string new_new_G =  mergestring(filter(`v, new_G_list,``(v != old_groupname) ),",");
			   usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_new_G, user ),
					 `edit_user,
					 sformat(UI(_("Can't add user %1 to group %2")), user, new_new_G));
		       });
		       
		   }
	       }
		
	       if ( old_groupname != new_groupname )
		   todo = todo + " -n " + new_groupname;
	       if ( lookup( lookup( current_groups , old_gid, $[] ), "gid"       , "" ) != gid )
		   todo = todo + " -g " + sformat("%1", gid) + " -o";

	       if ( todo != "/usr/sbin/groupmod" )
		   usersAddTodo( (todo + " " +  old_groupname),
				 `edit_group,
				 sformat(UI(_("Can't change the settings of the group %1")), old_groupname) );
	       
	      
	   }
	   
	   // bild todo aktion for gshadow
	   if( password != "x" )
	   {	
	       usersAddSetGroupPassword( new_groupname, password );

	       // if the user delet a password or a new group was added
	       // modify password for entry in current_groups
	       if ( password == "*" ) password = "x";
	   }
	   
	   map current_group = $[
				 "exist"         : do_exist,
				 "gid"           : gid,
				 "groupname"     : new_groupname,
				 "password"      : password, 
				 "userlist"      : new_userlist
	   ];


	   
	   // upadate current_users and current_groups if the gid was modified
	   if( old_gid != gid ) 
	   {
	       map new_current_groups = $[];
	       foreach( `key, `group, current_groups, ``{
		   if( key != old_gid) new_current_groups = add( new_current_groups, key, group );
	       });
	       current_groups = new_current_groups;

	       foreach( `key, `user, default_users, ``{

		   map new_user = user;
		   new_user = add( new_user, "gid", gid);
		   current_users = add(current_users, key, new_user);		   
	       });
	   }

	   // save current_group to current_groups
	   current_groups = add( current_groups, gid, current_group );


           // update current_gshadow
	   /*
	   map shadow_entry =  $[
				 "disposer"  : "root",
				 "groupname" : new_groupname,
				 "password"  : password,
				 "userlist"  : userlist
	   ];
	   
	   if( what != `add_group )
	   {
	       string old_groupname = lookup( lookup( current_groups , old_gid, $[] ), "groupname" , "" );
	       usersDeleteGroupFromShadow( old_groupname );
	       
	   }
	   current_gshadow = add( current_gshadow , shadow_entry );  
	   */
	   
	   // bild todo aktion
	   //if( (what == `edit_group && password != "*") ||
	   //    (what == `add_group) )
	   // {
	 
	   // }

	   //if test_mode
	   if( test_mode ) SCR( `Write(.dumpto.tmp.user_set_next,   user_settings  ));

	   if (  start_dialog == "group_add" ) return `save; 
	   return `next;
       }

    /**
     * Return counts of blanks 
     * This is used in <TT>usersGroupsRead</TT> and <TT>usersUsersRead</TT>.
     * @param integer <TT>count</TT>
     */ 
    global define AddBlanks(integer count ) ``{
	string  blanks = "";
	integer blanks_counter = 0;
	
	while (  blanks_counter <= count )
	{
	    blanks_counter = blanks_counter + 1;
	    blanks         = blanks + " ";
	}
	return blanks;
    }

    

    
    /**
     * Read the map current_groups
     * This is used in <TT>usersGroupsDialog</TT> and <TT>usersEditGroup</TT>.
     * @param symbol what can be <TT>`items</TT> or <TT>`groupnamelist</TT> 
     */
    global define usersGroupsRead(symbol todo ) ``{
	
	//build a list for the Group Table
	list    items         = [];
	list    groupnamelist = [];
	foreach ( `key, `group,  current_groups, ``{

	    if ( lookup(group ,"todo", "") != `delete )
	    {
		if( todo == `items )
		{
		    string  s_gid = sformat("%1", key   );
		    term    a     = `item(`id(key));

		     if( size( s_gid) != max_length_gid ) s_gid = AddBlanks( max_length_gid - size(s_gid)) + s_gid;
		     
		    a = add(a, lookup( group , "groupname" , "" ));
		    a = add(a, s_gid);
		    a = add(a, findUsersBelongGroup(key) );
		
		    items = add( items, a );
		}
		if ( todo == `groupnamelist)
		{
		    groupnamelist = add(groupnamelist, lookup( group , "groupname" , "" ));
		}
		
	    }
	});
	
	if( todo == `items              ) return items;
	else if (todo == `groupnamelist ) return groupnamelist;
    }


    
    /**
     * Read the map current_users
     * This is used in <TT>usersUsersDialog</TT> and <TT>usersEditUser</TT> 
     * @param symbol what can be <TT>`items</TT> or <TT>`usernamelist</TT> of <TT>`homelist</TT>
     */
    global define usersUsersRead(symbol todo) ``{
	
	
	list     todo_list    = [];
	list     items           = [];
	
	foreach ( `key, `user,  current_users, ``{
	    
	    if( lookup( user ,"todo", "") != `delete )
	    {
		string username = lookup( user , "username" , "");
		if( todo == `items )
		{	
		    string  s_uid = sformat("%1", key );
		    term    a     = `item(`id(key));
		    
		    if( size( s_uid) != max_length_uid ) s_uid = AddBlanks( max_length_uid - size(s_uid)) + s_uid;
		    
		    a =	add(a , username );
		    a = add(a, lookup( user , "fullname" , "" ));
		    a = add(a, s_uid );

		    string grouplist   = lookup(lookup( current_groups , lookup( user, "gid", 0)), "groupname");
		    string more_groups = findGroupsBelongUser( username );
	
		    
		    if ( contains ( splitstring( more_groups , "," ) , grouplist )) grouplist = more_groups;
		    else
		    {
			if( more_groups != "" ) grouplist = grouplist + "," + more_groups;
		    }
		   
		    a = add(a, grouplist );
		    
		    items = add( items, a );
		}
		else if ( todo == `usernamelist )
		{
		    todo_list = add( todo_list, lookup(user, "username" ));
		}
		else if ( todo == `homelist )
		{
		    todo_list = add( todo_list, lookup( user, "home" ));
		}
	    }
	});
		  
	if( todo == `items                               ) return items;
	else if( todo == `usernamelist || todo == `homelist ) return todo_list;
	
    }	


    /**
     * Return the next free Uid
     * This is used in <TT>usersEditUser</TT> 
     * @param 
     */
    global define usersFreeUid(map current_users) ``{

	integer uid     = max_system_uid + 1 ;
	repeat {
	    if (  haskey( current_users , uid) )
	    {
		map user =  lookup ( current_users , uid );
		if( lookup(user, "todo","") == `delete) return uid;
		else
		{
		    uid = uid + 1;
		}
	    }
	    else return uid;
		  
	} until ( uid == max_uid );	      
    }



    /**
     * Return the next free Gid
     * This is used in <TT>usersEditGroup</TT> 
     * @param 
     */
    global define usersFreeGid(map current_groups) ``{

	integer gid  = max_system_gid + 1;
	// can't delet gid 101 with groupdel ????
	// ERROR
	if ( gid == 101 ) gid = 102;

	repeat {
	    if ( haskey( current_groups, gid ) )
	    {
		map group = lookup( current_groups, gid );
		if( lookup( group, "todo", "")  == `delete) return gid;
		else
		{
		    gid = gid + 1;
		    if ( gid == 101 ) gid = 102;
		}
	    }
	    else return gid;
	} until ( gid == max_gid );
	return gid;
    }


    
    /**
     * Read the /etc/shells file and return a item list or a string shell list
     * This is used in <TT>usersEditUserDetails</TT>.
     * @param symbol what can be <TT>`items</TT> or <TT>`stringlist</TT> 
     */
    global define  usersReadShells(symbol todo ) ``{

	list available_shells =  [];
	list shells_read = SCR(`Read(.etc.shells));
	
	foreach( `shell_entry, shells_read, ``{
	    
	    if( is( shell_entry, string ))
	    { 
		if(/* ( ! issubstring( shell_entry, "true")) &&*/
		   /* ( ! issubstring( shell_entry, "false")) &&*/
		    (! issubstring( shell_entry, "passwd")) &&
		    (! issubstring( shell_entry, "bash1")) )
		{
		    if( fileexist( shell_entry ) )
		    {
			if ( todo == `items      )  available_shells = add( available_shells, `item(shell_entry ));
			if ( todo == `stringlist )  available_shells = add( available_shells, shell_entry);
		    }
		}
		    
	    }
	});


	return available_shells;
    }


    /**
     * Uncode the fullname
     * This is used in <TT>usersUsersReadFromDisk</TT>.
     * @param string <TT>fullname</TT>  
     */
    global define usersConsoleUncoding( string fullname ) ``{
	
	return UI(`Recode ( encoding,"utf-8",  fullname ));
    }

    /**
     * Encode the fullname
     * This is used in <TT>usersUserSaveToMap</TT>.
     * @param string <TT>fullname</TT>  
     */
    global define usersConsoleEncoding( string fullname ) ``{

	
	any ret = findfirstof( fullname , "\"" );
	
	if(  ret != nil )
	{
	    string split_list = splitstring( fullname, "\"");
	    fullname = "";
	    
	    foreach ( `split , split_list, ``{
		if( fullname == "" ) fullname = split;
		else fullname = fullname + "\\\"" + split; 
	    });
	}
	
	return  UI(`Recode ("utf-8", encoding, sformat("\"%1\"", fullname )));
    }


}
