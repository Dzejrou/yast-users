/**
 * File:
 *  users/io.ycp
 *
 * Module:
 *  Configuration of the users and groups
 *
 * Summary:
 *  Input/Output routines for the users module
 *
 * Authors:
 *  Jan Holesovsky <kendy@suse.cz>, 2001
 *  Johannes Buchhold <jbuch@suse.de>
 *
 * $Id$
 *
 * Input/Output routines.
 */

{

  textdomain "users";
  
    
    global define void save_focus( integer table_input, any ret , symbol what) ``{

	integer l_focusline = 0;
	
	if ( what == `group )
	    l_focusline = focusline_group;
	if ( what == `user )
	    l_focusline = focusline_user;
	
	
	if ( is ( table_input, integer ))
	{
	    l_focusline = table_input;
	    if( ret == `delete )
		l_focusline = 0;
	}
	if( l_focusline == nil || l_focusline < 0 )
	{
	    l_focusline = 0;
	}

	if ( what == `group )
	    focusline_group = l_focusline;
	if ( what == `user )
	    focusline_user = l_focusline;
    }

    
    /**
     * Return the group password if the group have a password ( use current_gshadow ).
     * @param groupname name of the group
     * @return string/nil
     */
    global define string usersGroupPassword( string groupname ) ``{
	
	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname","") == groupname ) );
	if( size (password_group_list ) == 0 ) return ( nil ) ;
	
	string password = lookup( select(password_group_list, 0,$[]) , "password", "" );
	if( (password != "*" ) &&
	    ( password  != "!" ) ) return password;
	return ( nil ) ;
    }

    
    /**
     * Delete the group with the groupname from current_gshadow.
     * @param groupname name of the group
     * @return nil
     */
    global define void usersDeleteGroupFromShadow( string groupname )``{
	current_gshadow  = filter(`k, current_gshadow , ``( lookup(k, "groupname", "") != groupname ) );
    }


    /**
     * Return the group with the groupname from current_gshadow.
     * @param groupname name of the group
     * @return map
     */
    global define map usersReturnGroupFromShadow( string groupname ) ``{
	list password_group_list  = filter(`k, current_gshadow , ``( lookup(k, "groupname","") == groupname ) );
	if ( size ( password_group_list ) == 0 ) return $[]; 
	return select(password_group_list, 0,$[]);
    }


    
   /**
   * Read the /etc/gshadow file and save it to current_gshadow. 
   * This is used in users.ycp and in usersSaveDialog()
   * @return nil
   */
    global define void usersGroupsShadowReadFromDisk() ``{
	
	current_gshadow  = SCR::Read(.etc.gshadow);
	current_gshadow  = filter(`k, current_gshadow , ``( size(k) > 1 ) );
	if( test_mode )    SCR::Write(.dumpto.tmp.current_gshadow,  current_gshadow  );
    }

    
    
  /**
   * This define returns the groups of a user.
   * This is used in usersUserSaveToMap, usersGroupSaveToMap, usersUsersRead and usersEditUser.
   * @param username string
   * @return string
   */
  global define string findGroupsBelongUser( string username ) ``{
   
      if( username == "" ) return "";
      string grouplist = "";
      foreach( `key, `group, current_groups , ``{
	  
	  string userlist = lookup( group, "userlist","");
	  if ( issubstring(userlist , username ))
	  {
	      string groupname = lookup( group, "groupname","");
	      if( grouplist == "" ) grouplist = groupname;
	      else grouplist = grouplist + "," + groupname;
	  }
      });
	
      if( grouplist != nil ) return grouplist;
      else return "";
  }


  
  global define list groupString2groupList(string str_grouplist )``{

      list false_grouplist = [];
      list true_grouplist  = [];
      list str_list_grouplist = splitstring( str_grouplist, "," );

      foreach( `key, `group, current_groups , ``{
	  string groupname = lookup( group, "groupname","");

	  if( ! contains( str_list_grouplist, groupname ) )
	  {
	      term    a     = `item(`id(groupname ), groupname, false );
	      false_grouplist     = add( false_grouplist ,  a );
	  }    
      });

    
      
      foreach( `groupname,  str_list_grouplist , ``{
	  
	  term    a     = `item(`id(groupname ), groupname, true );
	  true_grouplist     = add( true_grouplist ,  a ); 
      });

      true_grouplist  = sort(`x, `y, true_grouplist,  ``( x <= y ));
      false_grouplist = sort(`x, `y, false_grouplist, ``( x <= y ));
      
      return union( true_grouplist, false_grouplist);
    

  }

  
  
  
   /**
   * This define returns the users of a group.
   * This is used in usersGroupRead  and usersEditGroup.
   * @param gid integer
   * @return string
   */
  global define findUsersBelongGroup( integer gid, symbol what ) ``{

      if( what == `string )
      {
	  string userlist = lookup( lookup( current_groups, gid, $[]),  "userlist", "");
	  foreach( `key, `user, current_users , ``{
	  
	      if ( gid == lookup(user, "gid", -1 ) &&(! issubstring(userlist,  lookup( user, "username", "") )))
	      {
		  if( userlist == "") userlist = lookup( user, "username", "");
		  else userlist = userlist + "," + lookup( user, "username", "");
	      }
	  });
	  if (   userlist != nil )  return userlist;
	  else return "";
      }
      else
      {
      
	  string str_userlist    = lookup( lookup( current_groups, gid, $[]),  "userlist", "");
	  list str_list_userlist = [];

	  if( str_userlist != "" )
	      str_list_userlist = splitstring( str_userlist, "," );

	  list false_userlist          = [];
	  list true_userlist	       = [];

	  //y2milestone( "str_userlist %1 str_list_userlist %2", str_userlist, str_list_userlist );
	  
	  foreach( `key, `user, current_users , ``{

	      string username     =  lookup( user, "username", "");
	      //y2milestone( "%1", str_list_userlist );
	      
	      if( (! contains(str_list_userlist,  username ) ))
	      {  
		  if ( gid == lookup(user, "gid", -1))
		  {
		      term    a       = `item(`id(username), username, true );
		      true_userlist  =  add( true_userlist, a );  
		  }
		  else
		  {
		      term    a       = `item(`id(username), username, false );
		      false_userlist  =  add( false_userlist, a );   
		  }  
	      }
	    
	  });

	  foreach( `user, str_list_userlist, ``{
	      term    a     = `item(`id(user), user, true );
	      true_userlist = add( true_userlist, a );
	  });

	  true_userlist  = sort(`x, `y, true_userlist,  ``( x <= y ));
	  false_userlist = sort(`x, `y, false_userlist, ``( x <= y ));
	  
	  return union( true_userlist, false_userlist );
	
      }
  }
  

  /**
   * Read the /etc/passwd file and save it to current_users. 
   * This is used in users.ycp 
   * @return nil
   */
  global define void usersUsersReadFromDisk() ``{

	list users  = SCR::Read(.etc.passwd);
	foreach ( `user, users,  ``{
	    any i_uid = lookup(  user, "uid", 0);
	    user = add( user ,"exist", true);
	  
	    if( is( i_uid , integer ) )
	    {
		
		user = add( user , "fullname", usersConsoleUncoding( lookup( user, "fullname" ,"" )));
		current_users = add(current_users, i_uid , user );
	    }	
	});
    }


  /**
   * Read the /etc/group file and save it to current_groups. 
   * This is used in users.ycp.
   * @return nil
   */
  global define void usersGroupsReadFromDisk() ``{

	list groups = SCR::Read(.etc.group );
	foreach ( `group, groups,  ``{
	    
	    any i_gid = lookup( group, "gid", 0);
	    group = add(group, "exist", true);
	    if( is( i_gid , integer ) )
	    {
		//if a password in /etc/gshadow for this group a this password and
		//the group to current_groups
		string password =  usersGroupPassword( lookup( group, "groupname" , "" ));
		if ( password != nil ) group = add( group, "password", password );
		
		current_groups = add(current_groups, i_gid , group );
	    }	
	});
    }
 
   /**
    * Return the groupId of a groupname.
    * Not used 
    * @param groupname string
    * @return integer 
    */
   global define integer groupNameToId( string groupname) ``{

	integer ret = max_gid;
	foreach( `key, `group, current_groups, ``{
	    if( (lookup(group, "groupname", "") == groupname) &&
		(lookup(group, "todo", "" ) != `delete) )
		{
		    ret = key;
		}
	});
	return ret;
    }


   
   /**
    * Return the groupname of a groupId.
    * Used in usersUserSaveToMap.
    * @param Id integer
    * @return string
    */
    global define string groupIdToName( integer Id ) ``{
	return lookup(lookup( current_groups, Id,$[]), "groupname", "");
    }


    /**
     * Return the username of a userId.
     * Used in usersUserSaveToMap.
     * @param Id integer
     * @return string
     */
    global define string userIdToName( integer Id ) ``{
	return lookup( lookup( current_users, Id,$[]), "username", "");
    }


    /**
     * Return the size of the map user_settings.
     * Used in usersAddTodo.
     * @return integer
     */
    global define integer findNextTodoPos() ``{
	return  ( size( user_settings) + 1);
    }


    
    /**
     * Add a string to the map user_settings for a todo position.
     * Used in usersAddMakeHomeDir, usersAddMoveDir, usersAddChownHome,
     * usersUserSaveToMap, usersGroupSaveToMap, usersDeleteUser and
     * usersDeleteGroup
     * @param todo string
     * @param what symbol
     * @param error string
     * @return boolean
     */
    global define boolean usersAddTodo( string todo, symbol what, string error ) ``{
	
	user_settings = add( user_settings ,  findNextTodoPos(),  $[ "todo" : todo,
								     "what" : what,
								     "error": error ] );
	return true;
    }

    
    /**
     * Add a string to the map user_settings for creating a home dir for a new user.
     * Used in usersAddMoveDir and usersUserSaveToMap.
     * @param home string
     * @return nil
     */
    global define void usersAddMakeHomeDir( string home ) ``{

	list   split_home = splitstring( home, "/");
	string tmp_dir    = "";

	foreach( `sub_dir, split_home , ``{
	    if( sub_dir != "" )
	    {
		tmp_dir = tmp_dir + "/"+sub_dir;
		//milestone("be 2. dir");
		//if( nil == SCR(`Read(.target.dir , tmp_dir) ))
		if( SCR::Read(.target.size, tmp_dir ) == -1  )
		    usersAddTodo( ("/bin/mkdir " + tmp_dir),
				  `mkdir,
				  sformat(UI(_("Can't make directory %1")), tmp_dir));
	    }
	});
    }

    
    /**
     * Add a string to the map user_settings for creating a home dir for a new user.
     * Used in usersAddMoveDir and usersUserSaveToMap.
     * @param home string
     * @param old_home string
     * @return nil
     */ 
    global define void usersAddMoveDir(string old_home, string  home )``{

	usersAddTodo( ("/bin/mv " + old_home + " " +  home ),
		      `mv,
		      sformat(UI(_("Can't move old home directory %1
to new home directory %2")), old_home, home));
	

    }

    /**
     * Add a string to the map user_settings for removing a home directory.
     * Used in usersDeleteUser.
     * @param home string
     * @return nil
     */ 
    global define void usersAddRmDir( string  home )``{

	usersAddTodo( ("/bin/rm " +home + " -r" ),
		      `rm,
		      sformat(UI(_("Can't remove home directory %1.")),  home));
    }
    /**
     * Add a string to the map user_settings to set the home dir access right.
     * Used in usersUserSaveToMap.
     * @param home string
     * @param user string
     * @param group string
     * @return nil
     */ 
    global define void usersAddChownHome( string home, string user, string group)``{

	usersAddTodo(("/bin/chown  " + user + ":" + group + " " + home ),
		     `chown,
		     UI(_("Can't set user and group variable to the home directory")));
	
	usersAddTodo(("/bin/chmod g-rx " + home ),
		     `chown,
		     UI(_("Can't set read and write permissions to the home directory")));

	usersAddTodo(("/bin/chmod o-rx " + home ),
		     `chown,
		     UI(_("Can't set read and write permissions to the home directory")));
    }


    global define boolean usersAddSetGroupPassword( string groupname, string password ) ``{

	user_settings = add( user_settings ,
			     findNextTodoPos(),
			     $[
			       "groupname" : groupname,
			       "password"  : password,
			       "what" : `set_group_password, 
			       "error": UI(_("Can' set group password" ))
			     ]
			     );
	return true;
	
    }
    
    
    /**
     * Add a string to the map user_settings to save a new or modified user.
     * Used in sequenser.
     * @return symbol
     */ 
    global define symbol usersUserSaveToMap() ``{

	symbol  what     = lookup( user_in_work , "what"      , `nix );
	string  fullname = lookup( user_in_work , "fullname"  , ""   );
	integer gid      = lookup( user_in_work , "gid"       , max_gid );
	string  home     = lookup( user_in_work , "home"      , ""   );
	string  password = lookup( user_in_work , "password"  , ""   );
	string  shell    = lookup( user_in_work , "shell"     , ""   );
	integer uid      = lookup( user_in_work , "uid"       , max_uid );
	string  username = lookup( user_in_work , "username"  , ""   );
	string  grouplist= lookup( user_in_work , "grouplist" , ""   );
	string  todo     = "/usr/sbin/usermod";
	boolean do_exist = true;
	map     org_user = lookup( current_users, uid , $[]);
	string  comment  = usersConsoleEncoding( fullname );
		      
	// ToDo write a User;
	if ( what == `add_user )
	{
	    do_exist = false;

	    //add shell, home, initial_group, password, uid to string
	    todo = sformat("/usr/sbin/useradd -s %1 -d %2 -g %3 -m -p '%4' -u %5 -o",shell, home, groupIdToName(gid ), password, uid);

	    //add fullname to string (comment)
	    if ( comment  != "") todo = todo + " -c " + comment;

	    //add groups to string
	    if ( grouplist != "") todo = todo + " -G " + grouplist;

	    //add username to string
	    todo = todo + " " + username;

	    usersAddMakeHomeDir( home );

	    if(  SCR::Read(.target.size, "/usr/sbin/useradd.local" ) != -1  )
	    {	
		usersAddTodo( ("/usr/sbin/useradd.local " + username ),
			      `add_user_local,
			      UI(_("Can't execute /usr/sbin/useradd.local")));
	    }


	    usersAddTodo( todo ,
			  `add_user,
			  sformat(UI(_("Can't create the new user %1")), username ) );
	    
	    //usersAddChownHome( home, username , groupIdToName(gid ));
	}
	else
	{
	    //add initial_group to string 
	    if ( lookup( org_user, "gid" ,     "" ) != gid      )  todo = todo + " -g "  + groupIdToName(gid  );

	    //add comment to string 
	    if ( lookup( org_user, "fullname", "" ) != fullname )  todo = todo + " -c " + comment ;

	    //add home_dir to string
	    if ( lookup( org_user, "home" ,    "" ) != home     )
	    {
		todo = todo + " -d "  + home;
		usersAddMoveDir(lookup( org_user, "home" ,    "" ),  home );
	    }

	    //add password to string 
	    if ( "x" != password )  todo = todo + " -p '"  + password + "'";

	    //no change id at the moment 
            // if ( lookup( org_user, "uid",      "")  != uid     )  todo = todo + " -u " + sformat("%1", uid ) + " -o";

	    //add loginname to string
	    if ( lookup( org_user, "username" ,"")  != username )  todo = todo + " -l "  + username;

	    //add shell to string
	    if ( lookup( org_user, "shell" , "") != shell ) todo = todo + " -s " + shell;
	    
	    //add groups to  string
	    if ( findGroupsBelongUser(username )    != grouplist)
	    {
		if ( grouplist == "" ) grouplist = "''";
		todo = todo + " -G "  + grouplist;
	    }

	    // add username to string
	    if( todo !=  "/usr/sbin/usermod" )
	    {
		todo = todo + " " + userIdToName( uid );
	    
		usersAddTodo( todo,
			      `edit_user,
			      sformat(UI(_("Can't change the settings of the user %1")), username ));
	    
		/*
		if ( lookup( org_user, "username" ,"")  != username  ||
		     lookup( org_user, "gid" ,     "" ) != gid       ||
		     lookup( org_user, "home" ,    "" ) != home      	 )
		{  
		    usersAddChownHome( home, username , groupIdToName(gid ));
		}
		*/
	    }
	}


	
	map current_user = $[
			     "exist"    : do_exist,
			     "fullname" : fullname,
			     "gid"      : gid,
			     "home"     : home,
			     "password" : password,
			     "shell"    : shell,
			     "uid"      : uid,
			     "username" : username
	];	

	
	list search_groups = splitstring(grouplist, "," );

	
	// if the username was changed
	// the map current_groups must be updated
	map    tmp_current_groups = current_groups;
	string old_username       = lookup( org_user , "username" , "" );
	if ( old_username != username )
	{
	    map groups_with_old_username = filter(`k, `v, current_groups, ``( issubstring(lookup(v,"userlist",nil),old_username) == true ));
	    foreach( `key, `group, current_groups, ``{
		
		string userlist       =  lookup( group , "userlist" ,"");
		list   split_userlist =  splitstring( userlist, ",");
		if ( contains( split_userlist , old_username ) )
		{
		    list   new_userlist     =  filter(`v, split_userlist , ``(v != old_username ));
		    list   new_userlist     =  add( new_userlist, username );
		    string new_userlist_str =  mergestring( new_userlist, ",");
		    group  = add(group, "userlist", new_userlist_str );
		    tmp_current_groups = add( tmp_current_groups, key, group );
		}
	    });
	    current_groups = tmp_current_groups;
	}
	

	
	//If the userlist has changed the map current_groups 
	//must be updated
	// add or delete user from userlist
	foreach( `key, `group, tmp_current_groups, ``{
	    string userlist  = lookup(group, "userlist" , "");
	    map    new_group = group;
	    
	    if( issubstring( userlist, username ) &&( ! contains(search_groups, lookup( group, "groupname","")) ))
	    {
		//UI(`MessagePopup("delete " + username + " from " +  lookup( group, "groupname") ));
		// delete username from userlist
		list split_userlist = splitstring( userlist, ",");
		string new_userlist = "";
		
		foreach( `entry, split_userlist, ``{

		    if( entry != username )
		    {
			if( new_userlist == "") new_userlist = entry;
			else new_userlist = new_userlist + "," + entry;
		    }
		});
		new_group = add( new_group, "userlist", new_userlist );
		current_groups = add( current_groups, key , new_group );
	    }
	    if(	 contains(search_groups, lookup( group, "groupname","")) &&( ! issubstring( userlist, username )))
	    {
		//UI(`MessagePopup("add " + username + " to " + lookup( group, "groupname") ));
		// add username to userlist
		if ( userlist == "" ) userlist = username;
		else userlist = userlist + "," + username;

		new_group = add( new_group, "userlist", userlist );
		current_groups = add( current_groups, key , new_group );
	    }
	});
	current_users = add( current_users , uid, current_user );

	
	if( test_mode ) SCR::Write(.dumpto.tmp.user_settings,   user_settings  );

	//leave the module with save
	if (  start_dialog == "user_add" ) return `save;
	return `next;
    }

    
     /**
     * Add a string to the map user_settings to save a new or modified group. 
     * Used in sequenser.
     * @return symbol
     */ 
    global define symbol usersGroupSaveToMap( ) ``{

	   //load the manipulated group from group_in_work
	   symbol what             = lookup( group_in_work , "what" ,     "");
	   string new_groupname    = lookup( group_in_work, "groupname",  "");
	   string password         = lookup( group_in_work, "password",   "x");
	   string userlist         = lookup( group_in_work, "userlist",   "");
	   integer gid             = lookup( group_in_work, "gid",        "");
	   integer old_gid         = lookup( group_in_work, "old_gid",    "");
	
	 
	   // remove default user from the userlist
	   list   split_userlist = splitstring( userlist, ",");
	   string new_userlist   = "";
	   map    default_users  =  filter(`k, `v, current_users, ``(lookup(v,"gid",nilinteger) == old_gid) );
	   foreach(`entry, split_userlist, ``{
	      
	       if(  (size(filter(`k, `v, default_users, ``(lookup(v,"username",nilinteger ) == entry ))) == 0 ) ||
		    ( issubstring(lookup(lookup(current_groups, old_gid , $[] ), "userlist",""), entry ) ))
		   {
		       if( new_userlist == "") new_userlist = entry;
		       else new_userlist = new_userlist + "," + entry;       
		   }
	   });

	   
	   // build strings with the operation and save they to user_settings
	   string  todo     = "/usr/sbin/groupmod";	
	   boolean do_exist = true;
	   if ( what == `add_group )
	   {
	       do_exist = false;
	       
	       usersAddTodo( sformat("/usr/sbin/groupadd -g %1 -o %2", gid, new_groupname ),
			     `add_group,
			     sformat(UI(_("Can't create new group %1")), new_groupname));
	       
	       if ( userlist != "" )
	       {
		   list split_userlist = splitstring( userlist , "," );
		   foreach ( `user, split_userlist, ``{  
		       string new_G = findGroupsBelongUser(user);
		       if ( new_G != "" )  new_G = new_G + "," + new_groupname;
		       else new_G  = new_groupname;
		       usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_G, user ),
				     `edit_user,
				     sformat(UI(_("Can't add user %1 to group %2")), user, new_G));
		   });
	       }
	   }
	   else
	   {
	       string old_groupname = lookup( lookup( current_groups , old_gid, $[] ), "groupname" , "" );
	       
	       if ( lookup( lookup( current_groups , old_gid, $[] ), "userlist" ,  "" ) != userlist )
	       {
		   
		   string old_userlist       = lookup( lookup( current_groups , old_gid, $[] ), "userlist" ,  "" );
		   list   old_split_userlist = splitstring( old_userlist, ",");
		   list       split_userlist = splitstring(     userlist, ",");
		   symbol add_or_delete      = `add;
		   list  work_userlist       = [];
		   
		   
		   if ( size ( old_userlist ) < size( userlist ) )
		   {
		       //add user-s to group
		       foreach(`user, split_userlist ,``{
			   if( !contains( old_split_userlist, user) ) work_userlist = add( work_userlist, user );
		       });
		       
		       foreach( `user, work_userlist, ``{
			   string new_G = findGroupsBelongUser(user);
			   if ( new_G != "" )  new_G = new_G + "," + old_groupname;
			   else new_G  = old_groupname;
			   usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_G , user ),
					 `edit_user,
					 sformat(UI(_("Can't add user %1 to group %2")), user, new_G));
		       });
		   }
		   else
		   {
		       //delete user-s  from group
		       add_or_delete = `delete;
		       foreach(`user, old_split_userlist ,``{
			   if( !contains( split_userlist, user) ) work_userlist = add( work_userlist, user );
		       });
		       foreach( `user, work_userlist, ``{
			   string new_G      = findGroupsBelongUser(user );			   
			   list   new_G_list = splitstring( new_G , "," );
			   string new_new_G =  mergestring(filter(`v, new_G_list,``(v != old_groupname) ),",");
			   usersAddTodo( sformat("/usr/sbin/usermod -G '%1' %2", new_new_G, user ),
					 `edit_user,
					 sformat(UI(_("Can't add user %1 to group %2")), user, new_new_G));
		       });
		       
		   }
	       }
		
	       if ( old_groupname != new_groupname )
		   todo = todo + " -n " + new_groupname;
	       if ( lookup( lookup( current_groups , old_gid, $[] ), "gid"       , "" ) != gid )
		   todo = todo + " -g " + sformat("%1", gid) + " -o";

	       if ( todo != "/usr/sbin/groupmod" )
		   usersAddTodo( (todo + " " +  old_groupname),
				 `edit_group,
				 sformat(UI(_("Can't change the settings of the group %1")), old_groupname) );
	       
	      
	   }
	   
	   // bild todo aktion for gshadow
	   if( password != "x" )
	   {	
	       usersAddSetGroupPassword( new_groupname, password );

	       // if the user delet a password or a new group was added
	       // modify password for entry in current_groups
	       if ( password == "*" ) password = "x";
	   }
	   
	   map current_group = $[
				 "exist"         : do_exist,
				 "gid"           : gid,
				 "groupname"     : new_groupname,
				 "password"      : password, 
				 "userlist"      : new_userlist
	   ];


	   
	   // upadate current_users and current_groups if the gid was modified
	   if( old_gid != gid ) 
	   {
	       map new_current_groups = $[];
	       foreach( `key, `group, current_groups, ``{
		   if( key != old_gid) new_current_groups = add( new_current_groups, key, group );
	       });
	       current_groups = new_current_groups;

	       foreach( `key, `user, default_users, ``{

		   map new_user = user;
		   new_user = add( new_user, "gid", gid);
		   current_users = add(current_users, key, new_user);		   
	       });
	   }

	   // save current_group to current_groups
	   current_groups = add( current_groups, gid, current_group );


           // update current_gshadow
	   /*
	   map shadow_entry =  $[
				 "disposer"  : "root",
				 "groupname" : new_groupname,
				 "password"  : password,
				 "userlist"  : userlist
	   ];
	   
	   if( what != `add_group )
	   {
	       string old_groupname = lookup( lookup( current_groups , old_gid, $[] ), "groupname" , "" );
	       usersDeleteGroupFromShadow( old_groupname );
	       
	   }
	   current_gshadow = add( current_gshadow , shadow_entry );  
	   */
	   
	   // bild todo aktion
	   //if( (what == `edit_group && password != "*") ||
	   //    (what == `add_group) )
	   // {
	 
	   // }

	   //if test_mode
	   if( test_mode ) SCR::Write(.dumpto.tmp.user_set_next,   user_settings  );

	   if (  start_dialog == "group_add" ) return `save; 
	   return `next;
       }

    /**
     * Return counts of blanks.
     * This is used in usersGroupsRead and usersUsersRead.
     * @param count integer
     * @return string
     */ 
    global define string AddBlanks(integer count ) ``{
	string  blanks = "";
	integer blanks_counter = 0;
	
	while (  blanks_counter <= count )
	{
	    blanks_counter = blanks_counter + 1;
	    blanks         = blanks + " ";
	}
	return blanks;
    }

    

    
    /**
     * Read the map current_groups.
     * This is used in usersGroupsDialog and usersEditGroup.
     * @param todo `items or `groupnamelist
     * @return list
     */
    global define list usersGroupsRead(symbol todo ) ``{
	
	//build a list for the Group Table
	list    items         = [];
	list    groupnamelist = [];
	foreach ( `key, `group,  current_groups, ``{

	    if ( lookup(group ,"todo", "") != `delete )
	    {
		if( todo == `items  &&
		    ( view_all_groups || ( ! view_all_groups && (key > max_system_gid &&  group["groupname"]:"" != "nogroup" ))))
		{
		    string  s_gid = sformat("%1", key   );
		    term    a     = `item(`id(key));

		     if( size( s_gid) != max_length_gid ) s_gid = AddBlanks( max_length_gid - size(s_gid)) + s_gid;
		     
		    a = add(a, lookup( group , "groupname" , "" ));
		    a = add(a, s_gid);
		    a = add(a, findUsersBelongGroup(key, `string ) );
		
		    items = add( items, a );
		}
		if ( todo == `groupnamelist)
		{
		    groupnamelist = add(groupnamelist, lookup( group , "groupname" , "" ));
		}
		
	    }
	});
	
	if( todo == `items              ) return sort(`x, `y, items, ``( x > y ));
	else if (todo == `groupnamelist ) return groupnamelist;
    }


    
    /**
     * Read the map current_users.
     * This is used in usersUsersDialog and usersEditUser.
     * @param todo `items, `usernamelist or `homelist
     * @return list
     */
    global define list usersUsersRead(symbol todo) ``{
	
	
	list     todo_list    = [];
	list     items           = [];
	
	foreach ( `key, `user,  current_users, ``{
	    
	    if( lookup( user ,"todo", "") != `delete )
	    {
		string username = lookup( user , "username" , "");
		if( todo == `items &&
		    ( view_all_users || ( ! view_all_users && (key > max_system_uid  && user["username"]:"" != "nobody" ))))
		{	
		    string  s_uid = sformat("%1", key );
		    term    a     = `item(`id(key));
		    
		    if( size( s_uid) != max_length_uid ) s_uid = AddBlanks( max_length_uid - size(s_uid)) + s_uid;
		    
		    a =	add(a , username );
		    a = add(a, lookup( user , "fullname" , "" ));
		    a = add(a, s_uid );

		    string grouplist   = lookup(lookup( current_groups , lookup( user, "gid", 0),$[]), "groupname","");
		    string more_groups = findGroupsBelongUser( username );
	
		    
		    if ( contains ( splitstring( more_groups , "," ) , grouplist )) grouplist = more_groups;
		    else
		    {
			if( more_groups != "" ) grouplist = grouplist + "," + more_groups;
		    }
		   
		    a = add(a, grouplist );
		    
		    items = add( items, a );
		}
		else if ( todo == `usernamelist && username != "")
		{
		    todo_list = add(todo_list, username );
	
		}
		else if ( todo == `homelist && username != "" )
		{
		    todo_list = add(todo_list, username );
		}
	    }
	});
		  
	if( todo == `items                               ) return  sort(`x, `y, items, ``( x > y ));
	else if( todo == `usernamelist || todo == `homelist ) return todo_list;
	
    }	


    /**
     * Return the next free Uid.
     * This is used in usersEditUser.
     * @param current_users map
     * @return integer
     */
    global define integer usersFreeUid(map current_users) ``{

	integer uid     = max_system_uid + 1 ;
	repeat {
	    if (  haskey( current_users , uid) )
	    {
		map user =  lookup ( current_users , uid ,$[]);
		if( lookup(user, "todo","") == `delete) return uid;
		else
		{
		    uid = uid + 1;
		}
	    }
	    else return uid;
		  
	} until ( uid == max_uid );
	return uid;
    }



    /**
     * Return the next free Gid.
     * This is used in usersEditGroup .
     * @param current_groups map
     * @return integer
     */
    global define integer usersFreeGid(map current_groups) ``{

	integer gid  = max_system_gid + 1;
	// can't delet gid 101 with groupdel ????
	// ERROR
	if ( gid == 101 ) gid = 102;

	repeat {
	    if ( haskey( current_groups, gid ) )
	    {
		map group = lookup( current_groups, gid ,$[]);
		if( lookup( group, "todo", "")  == `delete) return gid;
		else
		{
		    gid = gid + 1;
		    if ( gid == 101 ) gid = 102;
		}
	    }
	    else return gid;
	} until ( gid == max_gid );
	return gid;
    }


    
    /**
     * Read the /etc/shells file and return a item list or a string shell list.
     * This is used in usersEditUserDetails.
     * @param todo `items or `stringlist 
     * @return list
     */
    global define  list usersReadShells(symbol todo ) ``{

	list available_shells =  [];
	list shells_read = SCR::Read(.etc.shells);
	
	foreach( `shell_entry, shells_read, ``{
	    
	    if( is( shell_entry, string ))
	    { 
		if(/* ( ! issubstring( shell_entry, "true")) &&*/
		   /* ( ! issubstring( shell_entry, "false")) &&*/
		    (! issubstring( shell_entry, "passwd")) &&
		    (! issubstring( shell_entry, "bash1")) )
		{
		    if(  SCR::Read(.target.size, shell_entry  )  != -1  )
		    {
			if ( todo == `items      )  available_shells = add( available_shells, `item( `id(shell_entry), shell_entry ));
			if ( todo == `stringlist )  available_shells = add( available_shells, shell_entry);
		    }
		}
		    
	    }
	});


	return available_shells;
    }


    /**
     * Uncode the fullname.
     * This is used in usersUsersReadFromDisk.
     * @param fullname string
     * @return boolean
     */
    global define boolean usersConsoleUncoding( string fullname ) ``{
	return UI::Recode( encoding,"utf-8",  fullname );
    }

    /**
     * Encode the fullname.
     * This is used in usersUserSaveToMap.
     * @param fullname string
     * @return boolean
     */
    global define boolean usersConsoleEncoding( string fullname ) ``{

	
	any ret = findfirstof( fullname , "\"" );
	
	if(  ret != nil )
	{
	    string split_list = splitstring( fullname, "\"");
	    fullname = "";
	    
	    foreach ( `split , split_list, ``{
		if( fullname == "" ) fullname = split;
		else fullname = fullname + "\\\"" + split; 
	    });
	}
	
	return  UI::Recode("utf-8", encoding, sformat("\"%1\"", fullname ));
    }



    global define integer getDefaultGid()``{
	
	string def_gid  = useradd_defaults["group"]:"100";
	integer def_int = tointeger(def_gid);
	
	if( lookup ( current_groups , def_int ,$[]) == $[])
	{
	    Report::Error(sformat(_("The default group with the id %1 does not exist.
Please change the default group in /etc/default/useradd."),def_int ));

	    /* TODO If group 100 does not exists ? */
	    return 100;
	}
	
	y2milestone("default integer : %1", def_int);
	return def_int;
	
    }

    global define string getDefaultHome()``{
	string def_home = useradd_defaults["home"]:"/home";

	/* TODO check if the directory exists */
	if ( (findlastof( def_home, "/") +1) != size(def_home ) )
	{
	    def_home = def_home + "/";
	}
	return def_home;
	
    }
    
    global define string getDefaultShell()``{
	return useradd_defaults["shell"]:"/bin/bash";
    }
    
}
