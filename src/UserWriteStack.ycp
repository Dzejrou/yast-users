 /**
 * Module:		UserWriteStack.ycp
 *
 * Authors:		Johannes Buchhold <jbuch@suse.de>
 *
 * Purpose:		this module handles a stack that
 *			contains all system changes executed
 *			by finishing the user module.
 *
 *
 * $Id$
 */
{

  module "UserWriteStack";
  textdomain "users";

  import "Wizard";
  import "Report";
  import "Mode";
  import "UserDefs";
  import "UserSettings";
  import "MailAliases";

  include "users/help.ycp";
  include "users/ui.ycp";

  global string chage = "/usr/bin/chage";
  global string useradd = "/usr/sbin/useradd";
  global string usermod = "/usr/sbin/usermod";
  global string userdel = "/usr/sbin/userdel";
  global string groupadd = "/usr/sbin/groupadd";
  global string groupdel = "/usr/sbin/groupdel";
  global string groupmod = "/usr/sbin/groupmod";

  global string root_mail = "";

  list write_to_system_stack = [];

  /**
   * Delete stack data.
   */
  global define void Reset()``{
      write_to_system_stack = [];
  }

  /**
   * Return true if the stack is empty.
   * @return boolean true if empty
   */
  global define boolean IsEmpty()``{
      return write_to_system_stack == [];
  }

  /**
   * Add an entry to the map write_to_system_stack for a todo position.
   * @param todo exec string
   * @param what symbol
   *  `set_group_password
   *  `add_user_local
   *  `add_user
   *  `edit_user
   *  `add_group
   *  `edit_user
   *  `mkdir
   *  `mv
   *  `del_user_local
   *  `del_user
   *  `del_group
   * @param error error message
   * @param type symbol `user of `group
   * @param id integer uid or gid depending on type
   * @return boolean true if success
   */
    global define boolean AddTodo( string todo, symbol what, string error, symbol type, integer id ) ``{
	write_to_system_stack = add (write_to_system_stack, $[
	    "todo" : todo,
	    "what" : what,
	    "error": error,
	    "type" : type,
	    "id" : id
	]);
	return true;
    }


  /**
   * Add a entry to the map write_to_system_stack to set a group password
   * @param groupname the name of the group
   * @param password the new group password
   * @return boolean true if success
   */
  define boolean addSetGroupPassword( string groupname, string password ) ``{

      write_to_system_stack = add (write_to_system_stack, $[
						      "groupname" : groupname,
						      "password"  : password,
						      "what" : `set_group_password,
							// error popup
						      "error": _("Cannot set group password")
      ]);
      return true;
  }




  /**
   * Encode the fullname of a user.
   * @param fullname the fullname of a user
   * @return string recoded fullname
   */
  define string consoleEncoding( string fullname ) ``{

	any ret = findfirstof( fullname , "\"" );

	if(  ret != nil )
	{
	    string split_list = splitstring( fullname, "\"");
	    fullname = "";

	    foreach ( `split , split_list, ``{
		if( fullname == "" ) fullname = split;
		else fullname = fullname + "\\\"" + split;
	    });
	}
	// if running in testsuite, UI::Recode returns nil !
	string s = UI::Recode("UTF-8", UserDefs::encoding, sformat("\"%1\"", fullname ));
	if (s == nil)
	    return sformat("\"%1\"", fullname );
	return s;
    }




    /**
     * Add entries to the map write_to_system_stack to save a new or modified user.
     * Update the virtual user and group settings in UserSettings.
     * @param user_in_work map of user to save
     * @param save_directly boolean true to save directly and not using WriteQueue
     * @return symbol for wizard sequencer
     */
    global define symbol UserSave(map user_in_work, boolean save_directly ) ``{
	symbol  what     = lookup( user_in_work , "what"      , `nix );
	string  fullname = lookup( user_in_work , "fullname"  , ""   );
	integer gid      = lookup( user_in_work , "gid"       ,  UserDefs::max_gid );
	string  home     = lookup( user_in_work , "home"      , ""   );
	string  password = lookup( user_in_work , "password"  , ""   );
	string  old_password = lookup( user_in_work , "old_password"  , ""   );
	string  shell    = lookup( user_in_work , "shell"     , ""   );
	integer uid      = lookup( user_in_work , "uid"       , UserDefs::max_uid );
	string  username = lookup( user_in_work , "username"  , ""   );
	string  grouplist= lookup( user_in_work , "grouplist" , ""   );
	string  todo     = usermod;
	boolean do_exist = true;
	map     org_user = UserSettings::GetUser( uid );
	string  comment  = consoleEncoding( fullname );
	boolean create_home = lookup (user_in_work, "create_home", true);
	boolean pwd_chng = lookup (user_in_work, "pwd_chng", false);
	symbol  user_type = lookup (user_in_work, "type", `passwd);

	if ( what == `add_user )
	{
	    do_exist = false;

	    //add the shell, home, initial_group, password, uid to the todo string
	    todo = sformat(useradd + " -s %1 -d %2 -g %3 -m -p '%4' -u %5 -o",shell,
			home, UserSettings::GroupIdToName(gid), password, uid);

	    //add the fullname to the todo string (comment)
	    if ( comment  != "") todo = todo + " -c " + comment;

	    //add the grouplist to the todo string
	    if ( grouplist != "") todo = todo + " -G " + grouplist;

	    //add the username to the todo string
	    todo = todo + " " + username;

	    //add the todo string to the write stack
	    // error popup, %1 is username
	    AddTodo( todo , `add_user,  sformat(_("Can't create the new user %1"), username ), `user, uid);

	    //add a call of useradd.local to the write stack
	    if(  SCR::Read(.target.size, "/usr/sbin/useradd.local" ) != -1  )
	    {
		AddTodo( ("/usr/sbin/useradd.local " + username ),
			      `add_user_local,
				// error popup
			      _("Can't execute /usr/sbin/useradd.local"), `user, uid);
	        if (! (create_home))
		{
		    AddTodo (sformat("/bin/chown -R %1:%2 %3", username, UserSettings::GroupIdToName(gid), home),
				`chown_home,
				// error popup
				_("Cannot chown home directory."), `user, uid);
		}
	    }
	}
	else
	{
	    boolean change_date = false;
	    //add the gid to the todo string
	    if ( org_user["gid"]:""  != gid )
		todo = todo + " -g "  + UserSettings::GroupIdToName(gid );

	    //add the fullname to the todo string
	    if ( org_user["fullname"]:"" != fullname )
		todo = todo + " -c " + comment ;

	    //add the home_dir to the todo string
	    if ( org_user["home"]:""  != home     )
		todo = todo + " -d "  + home + " -m";

	    //add the password to the todo string
	    if ( "x" != password && old_password != password)
	    {
		todo = todo + " -p '"  + password + "'";
		change_date = true;
	    }

	    //add the loginname to the todo string
	    if ( org_user["username"]:""  != username )
		todo = todo + " -l "  + username;

	    //add the shell to the todo string
	    if ( org_user["shell"]:"" != shell )
		todo = todo + " -s " + shell;

	    //add the grouplist to the todo string
	    if ( UserSettings::FindGroupsBelongUser(username )    != grouplist)
	    {
		if ( grouplist == "" ) grouplist = "''";
		todo = todo + " -G "  + grouplist;
	    }

	    if (user_type == `getent)
	    {
		pwd_chng = false;
		todo = sformat ("cp %4/passwd %4/passwd.y2backup;
echo '\n%2:x:65530:100:::\n' >>%4/passwd;
%3 -G %1 %2;
mv %4/passwd.y2backup %4/passwd;", grouplist, UserSettings::UserIdToName( uid ), usermod, UserSettings::base_dir);
	    }

	    //add the todo string to the write stack
	    if( todo !=  usermod )
	    {
		if (substring (todo, 0, 15) == substring (usermod, 0, 15))
		    todo = todo + " " + UserSettings::UserIdToName( uid );

		AddTodo( todo,
			      `edit_user,
				// error popup, %1 is username
			      sformat(_("Can't change the settings of the user %1"), username ), `user, uid);
		string today = lookup (SCR::Execute (.target.bash_output, ("date +\"%Y-%m-%d\"")), "stdout", "");
		if (change_date)
		{
		    today = substring (today, 0, 10);
		    todo = sformat (chage + " -d %1 %2", today, username);
				// error popup, %1 is username
		    AddTodo( todo, `edit_user, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
		}
	    }
	}

	if (pwd_chng)
	{
	    map shadow = lookup (user_in_work, "shadow", $[]);
	    integer val = lookup (shadow, "min", nil);
	    if (nil != val)
				// error popup, %1 is username
		AddTodo( sformat (chage + " -m %1 %2", val, username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
            val = lookup (shadow, "max", nil);
            if (nil != val)
				// error popup, %1 is username
                AddTodo( sformat (chage + " -M %1 %2", val, username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
            val = lookup (shadow, "warn", nil);
            if (nil != val)
				// error popup, %1 is username
                AddTodo( sformat (chage + " -W %1 %2", val, username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
            val = lookup (shadow, "inact", nil);
            if (nil != val)
				// error popup, %1 is username
                AddTodo( sformat (chage + " -I %1 %2", val, username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
	    string sval = substring (lookup (shadow, "expire", nil), 0, 10);
            if (regexpmatch (sval, "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"))
				// error popup, %1 is username
                AddTodo( sformat (chage + " -E %1 %2", sval, username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
	    else
				// error popup, %1 is username
		AddTodo( sformat (chage + " -E -1 %1", username), what, sformat(_("Cannot change the password settings of user %1."), username ), `user, uid);
	}

	map current_user = $[
			     "exist"    : do_exist,
			     "fullname" : fullname,
			     "gid"      : gid,
			     "home"     : home,
			     "password" : password,
			     "shell"    : shell,
			     "uid"      : uid,
			     "username" : username,
			     "org_home" : user_in_work["org_home"]:"",
			     "shadow"	: user_in_work["shadow"]:$[]
	];




	// if the username has been changed update the map current_groups
	UserSettings::ChangeUserNameInGroups( org_user["username"]:"", username);

	// if the userlist has been changed update the map current_groups
	UserSettings::ChangeUserlistInGroups( username, grouplist );

	// write changed user to current_users
	UserSettings::SetUser( uid, current_user );

	//leave the module with save
	if ( save_directly ) return `save;

	return `next;
    }


     /**
     * Add entries to the map write_to_system_stack to save a new or modified group.
     * Update the virtual user and groups settings.
     * @param group_in_work map of selected group
     * @param save_directly boolean true to save directly and not using WriteQueue
     * @return symbol for wizard sequencer
     */
    global define symbol GroupSave(map group_in_work , boolean save_directly ) ``{
	   //load the manipulated group settings from group_in_work
	   symbol what             = lookup( group_in_work , "what" ,     "");
	   string new_groupname    = lookup( group_in_work, "groupname",  "");
	   string password         = lookup( group_in_work, "password",   "x");
	   string userlist         = lookup( group_in_work, "userlist",   "");
	   integer gid             = lookup( group_in_work, "gid",        "");
	   integer old_gid         = lookup( group_in_work, "old_gid",    "");

	   // remove default user from the userlist
	   list   split_userlist = splitstring( userlist, ",");

	   string new_userlist = UserSettings::RemoveDefaultUserFromUserlist( old_gid, split_userlist);

	   // build strings with the operation and save they to write_to_system_stack
	   string  todo     = groupmod;
	   boolean do_exist = true;


	   if ( what == `add_group )
	   {
	       // create a new group
	       do_exist = false;

	       // create the group
	       AddTodo( sformat(groupadd + " -g %1 -o %2", gid, new_groupname ),
			`add_group,
			// error popup, %1 is group name
			sformat(_("Can't create new group %1"), new_groupname), `group, gid);

	       // add users to the group
	       if ( userlist != "" )
	       {
		   map ubn = UserSettings::UsersByName ();
		   map gbu = UserSettings::SortGroupsByUsers ();
		   list split_userlist = splitstring( userlist , "," );
		   foreach ( `user, split_userlist, ``{
		       integer uid = ubn[user]:UserDefs::max_uid;
		       string new_G = UserSettings::FindGroupsBelongUserHint (user, gbu);
		       if ( new_G != "" )  new_G = new_G + "," + new_groupname;
		       else new_G  = new_groupname;
		       AddTodo( sformat(usermod + " -G '%1' %2", new_G, user ),
				`edit_user,
				// error popup, %1 is username, %2 groupname
				sformat(_("Can't add user %1 to group %2"), user, new_G), `user, uid);
		   });
	       }
	   }
	   else
	   {
	       // modify a existing group
	       string old_groupname = UserSettings::GetGroupname( old_gid );

	       // it was compared against userlist, bug 20360
	       if ( UserSettings::GetUserlist( old_gid ) != new_userlist )
	       {

		   string old_userlist       = UserSettings::GetUserlist( old_gid );
		   list   old_split_userlist = splitstring( old_userlist, ",");
		   list       split_userlist = splitstring( new_userlist, ",");

		   // Fix bug 20363:
		   // Find out which users to add and delete:
		   // added users will have a +1, deleted ones a -1,
		   // unchanged ones a 0
		   map diff_users = listmap (string u, old_split_userlist, ``(
						 [ u, -1 ]
						 ));
		   foreach (string u, split_userlist, ``{
		       diff_users[u] = diff_users[u]:0 + 1;
		   });

		   map ubn = UserSettings::UsersByName ();
		   map gbu = UserSettings::SortGroupsByUsers ();

		   foreach (string user, integer action, diff_users, ``{
		       if (action > 0)
		       //add users to group
		       {
			   integer uid = ubn[user]:UserDefs::max_uid;
			   string new_G = UserSettings::FindGroupsBelongUserHint (user, gbu);
			   if ( new_G != "" )  new_G = new_G + "," + old_groupname;
			   else new_G  = old_groupname;
			   AddTodo( sformat(usermod + " -G '%1' %2", new_G , user ),
					 `edit_user,
					// error popup, %1 is username, %2 groupname
					 sformat(_("Can't add user %1 to group %2"), user, new_G), `user, uid);
		       }
		       else if (action < 0)
		       //delete users from group
		       {
			   integer uid = ubn[user]:UserDefs::max_uid;
			   string new_G = UserSettings::FindGroupsBelongUserHint (user, gbu);
			   list   new_G_list = splitstring( new_G , "," );
			   string new_new_G =  mergestring(filter(`v, new_G_list,``(v != old_groupname) ),",");
			   AddTodo( sformat(usermod + " -G '%1' %2", new_new_G, user ),
					 `edit_user,
					// error popup, %1 is username, %2 groupname
					 sformat(_("Can't add user %1 to group %2"), user, new_new_G), `user, uid);
		       }
		   });
	       }

	       if ( old_groupname != new_groupname )
		   todo = todo + " -n " + new_groupname;
	       if ( lookup( UserSettings::GetGroup( old_gid ), "gid"       , "" ) != gid )
		   todo = todo + " -g " + sformat("%1", gid) + " -o";

	       if ( todo != groupmod )
		   AddTodo( (todo + " " +  old_groupname),
				 `edit_group,
					// error popup, %1 is groupname
				 sformat(_("Can't change the settings of the group %1"), old_groupname), `group, gid);


	   }

	   // build todo aktion for gshadow
	   if( password != "x" )
	   {
	       addSetGroupPassword( new_groupname, password );

	       // modify password entry in current_groups
	       if ( password == "*" ) password = "x";
	   }

	   map current_group = $[
				 "exist"         : do_exist,
				 "gid"           : gid,
				 "groupname"     : new_groupname,
				 "password"      : password,
				 "userlist"      : new_userlist
	   ];



	   // upadate current_users and current_groups if the gid was modified
	   if( old_gid != gid )
	   {
	       UserSettings::ChangeGid( old_gid, gid ,current_group );
	   }
	   else
	   {
	       // save current_group to current_groups
	       UserSettings::SetGroup( gid, current_group );
	   }

	   if (  save_directly  ) return `save;
	   return `next;
       }

  /**
   * Dialog to save the Groups and Usersettings to system
   * @param useUI boolean true to set change UI (progress bar)
   * @return symbol for wizard sequencer
   */
  global define symbol SaveDialog(boolean useUI ) ``{
	if ( IsEmpty() ) return `next;

	UserSettings::BackupConfFiles();

	// normal, running system
	if( ! Mode::cont && ! Mode::autoinst && useUI )
	{
	    term contents =   `VBox(
				    `VSpacing( 2 ),
					// heading
				    `Left(`Heading (_("Save modified settings to system."))),
					// progress bar label
				    `HVCenter(`ProgressBar(`id(`bar), _("save ......"))),
				    `VSpacing( 2 )
				    );

	    Wizard::SetContentsButtons(  "" ,
					 contents,
					 usersSaveDialogHelp(),
					 UI::BackButtonLabel(),
					 UI::NextButtonLabel());
	}



	if( Mode::test ) SCR::Write(.dumpto.tmp.current_users_final,     UserSettings::current_users );
	if( Mode::test ) SCR::Write(.dumpto.tmp.current_groups_final,    UserSettings::current_groups );

	integer value = 0;
	boolean ok    = true;
	boolean is_nis_master = UserSettings::isNisMaster ();
	string command = "";

	foreach( `todomap, write_to_system_stack, ``{

	    symbol what  = lookup ( todomap , "what" , `error );
	    map ret = $[];
	    y2debug ("Processing %1", todomap);

	    if( what == `set_group_password )
	    {

		string groupname = lookup ( todomap , "groupname" ,"");
		string password  = lookup ( todomap , "password"  ,"");

		//read the /etc/gshado file new
		UserSettings::ReadGshadowFromDisk();

		//get groupmap from  current_gshadow
		map group       = UserSettings::GetGroupFromShadow(  groupname );

		//delete this map in current_gshadow
		if ( group != $[] )  UserSettings::DeleteGroupFromShadow( groupname );

		//add a new  groupmap to current_gshadow
		map new_group       = $[
					"password" : password,
					"disposer" : "root" ,
					"groupname": groupname,
					"userlist" : lookup( group , "userlist" ,"")
		];

		UserSettings::AddGshadowEntry(new_group);

		//save /etc/gshadow file
		boolean r = SCR::Write (.etc.gshadow, UserSettings::current_gshadow);
		ret = $["exit" : r ? 0 : 1];
		command = "write /etc/shadow";
	    }
	    else
	    {
		// execute the save string from write_to_system_stack
		string todo  = lookup ( todomap , "todo" , "" );
		command = todo;
		ret = SCR::Execute(.target.bash_output, todo );
	    }

	    if (lookup (ret, "exit", 0) == 0 && is_nis_master)
	    {
		ret = SCR::Execute(.target.bash_output, "/usr/bin/make -C /var/yp");
		command = "/usr/bin/make -C /var/yp";
	    }

	    if( lookup (ret, "exit", 1)  == 0 )
	    {
		value	= value + 1;
		if( ! Mode::cont && ! Mode::autoinst && useUI) {
		    UI::ChangeWidget(`id(`bar), `Value, ((value / size(write_to_system_stack))  * 100 ) );
		}
	    }
	    else
	    {
		ok = false;
		Report::Error( lookup ( todomap , "error", "" ));
		y2error ("Error: command: %4, exit code: %1, stdout: %2, stderr: %3",
		    lookup (ret, "exit", "unknown"), lookup (ret, "stdout", "unknown"), lookup (ret, "stderr", "unknown"),
		    command);
	    }
	});

	if (Mode::cont && root_mail != "")
        {
            boolean ret = MailAliases::SetRootAlias (root_mail);
	    if (! ret)
		// error popup
		Report::Error(_("There was an error while setting forwarding for root's mail."));
	    ok = ok && ret;
        }


	if ( !ok)
	{
		// error popup
	    Report::Error(_("The new user and group are not configured."));

	}
	else
	{
	    // normal, running system
	    if( ! Mode::cont && ! Mode::autoinst && useUI )
	    {
		// popup
		Report::Message(_("The new user and group settings
are configured and usable"));
	    }
	}



	return `next;
    }
}
